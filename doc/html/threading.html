<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PresenZ SDK: Threading and data management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PresenZ SDK<span id="projectnumber">&#160;5.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('threading.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Threading and data management</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__c_1_2_build_agent_2work_2dde19f8a29dab9da_2resources_2_s_d_k_2manual_205-threading"></a>Modern renderers parallelize work across many CPU cores, e.g., by splitting the image into smaller regions processed in parallel.</p>
<p>One common method is to cut the image into small patches and assign them to available computing units (threads). In practice, each patch is assigned to one thread; every sample processed in that patch is then sent into a <b>bucket</b>. Buckets are meant to be operated by a single thread at a time.</p>
<div class="image">
<img src="buckets.png" alt=""/>
</div>
    <p>Another method is to dispatch each pixel—or even each sample—to different threads and write results to disk in buckets (or batches) of variable sizes.</p>
<p><a class="el" href="namespace_presen_z.html">PresenZ</a> supports both approaches via two integration modes:</p>
<ul>
<li><b>Internal Bucket system</b> — you explicitly manage bucket/tile lifecycles and push samples into <b>PresenZ-managed buckets</b>. Because <a class="el" href="namespace_presen_z.html">PresenZ</a> manages the bucket memory, this mode is independent of the renderer’s own tiling system. <br  />
 <b>Constraint:</b> all pixels belonging to a given <a class="el" href="namespace_presen_z.html">PresenZ</a> bucket <b>must be rendered on the same thread</b>. <br  />
 <b>Used by:</b> our VRay plugin.</li>
<li><b>Data flow mode</b> — you hand samples to <a class="el" href="namespace_presen_z.html">PresenZ</a> <b>whenever you want</b>, and <b>you</b> are responsible for carrying the resulting data up to the driver stage where it is written to disk. In practice, you rely on the renderer’s native data flow (e.g., its <b>AOV system</b>) to move data from shader → filter → driver. <br  />
 <b>Used by:</b> our Arnold plugin.</li>
</ul>
<p>Select the mode at initialization:</p>
<div class="fragment"><div class="line">PzSetPresenZBucket(<span class="keyword">true</span>);  <span class="comment">// Bucket mode (push into PresenZ buckets)</span></div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">PzSetPresenZBucket(<span class="keyword">false</span>); <span class="comment">// Data flow mode (deferred flush via renderer/AOVs)</span></div>
</div><!-- fragment --><p>In both modes, <a class="el" href="namespace_presen_z.html">PresenZ</a> eventually writes to temporary files. If you invoke <a class="el" href="namespace_presen_z.html">PresenZ</a> termination/finalization from a thread-safe section of your renderer, you can disable PresenZ’s own output locking to avoid double-locking: </p><div class="fragment"><div class="line">PzSetOutputThreadSafety(<span class="keyword">false</span>);</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md34"></a>
5.1 Internal Bucket system</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
5.1.1 System Initialization</h2>
<div class="fragment"><div class="line">PzSetPresenZBucket(<span class="keyword">true</span>);  <span class="comment">// Bucket mode</span></div>
<div class="line">PzSetThreadNumber(maxRenderThreads); <span class="comment">// Create that many buckets.</span></div>
<div class="line">PzSetBucketSize(64, 64); </div>
</div><!-- fragment --><p>PzSetBucketSize(w, h) sets the maximum expected region size for any active bucket. Actual buckets may be smaller (e.g., edge tiles), but must never exceed this size.</p>
<blockquote class="doxtable">
<p>&zwj;Ownership rule: a given bucketId is operated by exactly one thread at a time; do not split one <a class="el" href="namespace_presen_z.html">PresenZ</a> bucket across threads. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md36"></a>
5.1.2 Bucket initialization/termination</h2>
<p><a class="el" href="namespace_presen_z.html">PresenZ</a> expects the renderer to notify when a bucket begins and ends.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
Initialization</h3>
<p>During initialization, provide a bucketId (between 0 and N) and the screen-space bounds:</p>
<div class="fragment"><div class="line"><span class="comment">// Start of a PresenZ bucket (screen-space region)</span></div>
<div class="line"><span class="keywordtype">void</span> PzInitBucket(<span class="keywordtype">int</span> bucketId, <span class="keywordtype">int</span> topX, <span class="keywordtype">int</span> topY, <span class="keywordtype">int</span> bottomX, <span class="keywordtype">int</span> bottomY);</div>
</div><!-- fragment --><p> After initialization, a bucket can be referenced either by its bucketId.</p>
<h3><a class="anchor" id="autotoc_md38"></a>
Termination</h3>
<p>When a bucket is finished, flush it to the disk: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> PzProcessBucketFlushToFile(bucketId);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keywordtype">bool</span> PzProcessBucketFlushToFile(<span class="keywordtype">int</span> topX, <span class="keywordtype">int</span> topY, <span class="keywordtype">int</span> bottomX, <span class="keywordtype">int</span> bottomY);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
5.1.3 Sending data to a bucket</h2>
<h3><a class="anchor" id="autotoc_md40"></a>
Detection Phase</h3>
<p>PzProcessDetectSample(intfPtr, sampleInfo, threadIndex) writes detection results to the bucket identified by threadIndex.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
Render Phase</h3>
<p>Create a PzRenderSample, populate its fields, then push it: </p><div class="fragment"><div class="line">PzRenderSample sample;</div>
<div class="line">PzSetSamplePosition(sample, hitPointWorld);</div>
<div class="line">PzSetSamplePosXY(sample, rc.rayparams.getScreenX(), rc.rayparams.getScreenY());</div>
<div class="line">PzSetSampleZ(sample, <a class="code hl_function" href="group___n_o_z__vector.html#gaec436ed5ffc599d804a9fd8fb464b70d">NozVecDist</a>(hitPointWorld, rayStart));</div>
<div class="line">PzSetSampleColor(sample, <a class="code hl_struct" href="struct_noz_r_g_b_a.html">NozRGBA</a>(leftColor.r, leftColor.g, leftColor.b, alpha));</div>
<div class="line"><span class="comment">// (check PresenZIntersectionShader::outputRenderSample in our Vray plugin)</span></div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//Forward to the current bucket</span></div>
<div class="line">PzProcessRenderSample(bucketId, sampleX, sampleY, sample);</div>
<div class="ttc" id="agroup___n_o_z__vector_html_gaec436ed5ffc599d804a9fd8fb464b70d"><div class="ttname"><a href="group___n_o_z__vector.html#gaec436ed5ffc599d804a9fd8fb464b70d">NozVecDist</a></div><div class="ttdeci">float NozVecDist(const NozPoint2 &amp;p1, const NozPoint2 &amp;p2)</div><div class="ttdoc">Distance between two points: ||p1-p2||.</div><div class="ttdef"><b>Definition</b> vector.h:522</div></div>
<div class="ttc" id="astruct_noz_r_g_b_a_html"><div class="ttname"><a href="struct_noz_r_g_b_a.html">NozRGBA</a></div><div class="ttdoc">RGB color + alpha.</div><div class="ttdef"><b>Definition</b> color.h:305</div></div>
</div><!-- fragment --><p>Lifecycle summary:</p>
<div class="fragment"><div class="line"><span class="comment">// Start of a PresenZ bucket (screen-space region)</span></div>
<div class="line"><span class="keywordtype">void</span> PzInitBucket(<span class="keywordtype">int</span> bucketId, <span class="keywordtype">int</span> topX, <span class="keywordtype">int</span> topY, <span class="keywordtype">int</span> bottomX, <span class="keywordtype">int</span> bottomY);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// While shading inside that bucket (Detect/Render phases)</span></div>
<div class="line">PzProcessRenderSample(bucketId, x, y, 0 <span class="comment">/*sampleIdx*/</span>, sample);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When the bucket is complete</span></div>
<div class="line"><span class="keywordtype">bool</span> PzProcessBucketFlushToFile(<span class="keywordtype">int</span> bucketId);</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>&zwj;Samples are accumulated per <a class="el" href="namespace_presen_z.html">PresenZ</a> bucket and reduced to pixel values at bucket termination. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md42"></a>
5.1.4 Serializing buckets for distributed rendering</h2>
<p>If work is dispatched across machines, bucket contents can be serialized and transmitted. Query the required buffer size:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> PzProcessBucketGetBufferSize(bucketId);</div>
</div><!-- fragment --><p> Copy the bucket into an allocated buffer:: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> PzBucketFlushToMemory(bucketId, bufferSize, buffer);</div>
</div><!-- fragment --><p> On the receiving node, write the buffer to disk:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> PzFlushMemoryBufferToFile(buffer, bufferSize);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md43"></a>
5.2 Data Flow mode</h1>
<h2><a class="anchor" id="autotoc_md44"></a>
5.2.1 System Initialization</h2>
<p>Disable the internal bucket system: </p><div class="fragment"><div class="line">PzSetPresenZBucket(<span class="keyword">false</span>); <span class="comment">// Data flow mode</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md45"></a>
5.2.2 Detection Phase</h2>
<p>At intersection/shader level, declare callbacks to (1) store detection data for later stages, and (2) retrieve the previous camera-ray intersection if any (for glass, etc.): </p><div class="fragment"><div class="line"><a class="code hl_struct" href="struct_presen_z_1_1_detect_sample_1_1v5__0_1_1_ray_test_interface.html">PresenZ::DetectSample::RayTestInterface</a> probe(</div>
<div class="line">    &amp;userData,</div>
<div class="line">    HitTest,</div>
<div class="line">    QueryFlags,</div>
<div class="line">    SaveDetect,          <span class="comment">// your storage callback</span></div>
<div class="line">    GetPreviousHitData   <span class="comment">// retrieves previous hit</span></div>
<div class="line">);</div>
<div class="line"><a class="code hl_function" href="group___pz_detect_sample_api.html#ga50a309149dfd3120e636960a329bba53">PresenZ::DetectSample::PzProcessDetectSample</a>(&amp;probe, sample); <span class="comment">// no thread id needed</span></div>
<div class="ttc" id="agroup___pz_detect_sample_api_html_ga50a309149dfd3120e636960a329bba53"><div class="ttname"><a href="group___pz_detect_sample_api.html#ga50a309149dfd3120e636960a329bba53">PresenZ::DetectSample::v5_0::PzProcessDetectSample</a></div><div class="ttdeci">NozRGBA PzProcessDetectSample(RayTestInterface *intfPtr, const PzDetectSample &amp;sample, const size_t &amp;threadIndex)</div><div class="ttdoc">During the detection phase, ray intersections need to be notified to PresenZ through PzProcessDetectS...</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v5__0_1_1_ray_test_interface_html"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v5__0_1_1_ray_test_interface.html">PresenZ::DetectSample::v5_0::RayTestInterface</a></div><div class="ttdoc">This interface is forwarded to PzProcessDetectSample() so that PresenZ can perform an additional visi...</div><div class="ttdef"><b>Definition</b> PzDetectSampleApi.h:94</div></div>
</div><!-- fragment --><p> PzProcessDetectSample() invokes your SaveDetect callback with a PresenZ::DetectSample::SaveDataStructure. You must persist this data—either in your own memory structures or via the renderer’s AOVs (as in our Arnold plugin).</p>
<p>When you need to free memory or reach a natural boundary (tile/scanline/frame), flush the packets:</p>
<div class="fragment"><div class="line">PzFlushSamplesToFile(savedData);</div>
</div><!-- fragment --><p>PzFlushSamplesToFile() acquires an internal lock while writing; call it as infrequently as practical (batch your flushes).</p>
<h2><a class="anchor" id="autotoc_md46"></a>
5.2.3 Render Phase</h2>
<p>First, collect all sub-pixel samples for a given pixel: </p><div class="fragment"><div class="line">std::vector&lt;PzRenderSample&gt; renderSamples;</div>
<div class="line">PzRenderSample sample;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numSamples; ++i) {</div>
<div class="line">    PzSetSamplePosition(sample, pos);</div>
<div class="line">    PzSetSampleNormal(sample, normal);</div>
<div class="line">    PzSetSampleZ(sample, Zvalue);</div>
<div class="line">    PzSetSampleDepth(sample, currentDepth);</div>
<div class="line">    PzSetSamplePosXY(sample, x, y);</div>
<div class="line">    PzSetSampleColor(sample, rgba);</div>
<div class="line">    renderSamples.push_back(sample);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Then filter/compact them into a driver-ready payload:</p>
<div class="fragment"><div class="line">std::vector&lt;PresenZ::RenderSample::PzFilteredSample&gt; filteredSamples;</div>
<div class="line">PzFilterRenderSample(x, y, renderSamples, filteredSamples);</div>
</div><!-- fragment --><p> When you need to free memory or reach a natural boundary (tile/scanline/frame), flush the prepared packets: </p><div class="fragment"><div class="line">PzFlushSamplesToFile(filteredSamples)</div>
</div><!-- fragment --><p>PzFlushSamplesToFile() acquires an internal lock while writing; call it as infrequently as practical (batch your flushes). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PresenZ SDK: Detection phase and render phase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PresenZ SDK<span id="projectnumber">&#160;5.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('phases.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Detection phase and render phase</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__c_1_2_build_agent_2work_2dde19f8a29dab9da_2resources_2_s_d_k_2manual_204-phases"></a> </p>
<h1><a class="anchor" id="autotoc_md22"></a>
4.1 Detection phase</h1>
<p>The Detection Phase will identify which parts of the scene are viewable from within the Zone Of View and will return a przDetect file that is necessary to execute the Render Phase. Below, an overview is given of the several calls your plugin will need to make to let the Render Engine work with <a class="el" href="namespace_presen_z.html">PresenZ</a>.</p>
<div class="image">
<img src="detectPhase.png" alt=""/>
<div class="caption">
Detection Phase Overview</div></div>
    <h2><a class="anchor" id="autotoc_md23"></a>
4.1.1 Requirements</h2>
<p>As previously mentioned in Section 2, the first phase must issue exactly 256 samples per pixel. <a class="el" href="namespace_presen_z.html">PresenZ</a> will require a small implementation (callback) that can check whether there is a line of sight between two points. To be more specific, this callback is used to check if scene geometry is visible from a certain camera .</p>
<h2><a class="anchor" id="autotoc_md24"></a>
4.1.2 Casting Detection Rays</h2>
<p>When rendering the detection phase we need to go over every pixel in the image and launch a ray for it with PzGetRayDetectPhase(). It is necessary to request the camera origin/direction for each pixel on the target image. This is usually done in the implementation of the camera. To help keep track of the sample index count - an internal counter of <a class="el" href="namespace_presen_z.html">PresenZ</a> that tells us how many of the 256 samples we have cast for a pixel- you should also call PzGetCurrentSampleIndexCount() beforehand. An example is presented below:</p>
<pre class="fragment">const int x = static_cast&lt;int&gt;(pixelX), y = static_cast&lt;int&gt;(pixelY);
size_t pixelSampleIndex = 0;
PresenZ::Camera::PzGetCurrentSampleIndexCount(x, y, pixelSampleIndex)
PresenZ::Camera::PzCameraRay rayCtx =
      PresenZ::Camera::PzGetRayDetectPhase(pixelSampleIndex, pixelX,
           pixelY);
</pre><p>After getting the ray context for a pixel, the data it contains should be forwarded to the ray structure of your current render engine.</p>
<pre class="fragment">struct PzCameraRay
{
    inline PzCameraRay() : valid(false) {}
    bool valid;      // True if the ray should be cast, False if the ray can be
                        discarded.
    NozVector origin; // ray origin
    NozVector dir;   // ray direction
    NozVector dDdx;  // ray direction derivatives with respect to x
    NozVector dDdy;  // ray direction derivatives with respect to y
};
</pre> <h2><a class="anchor" id="autotoc_md25"></a>
4.1.3 Creating a hit test callback function</h2>
<p>To check whether a point B is visible from point A, a hit test function needs to be created. This function is render engine dependent and needs to be given to <a class="el" href="namespace_presen_z.html">PresenZ</a> as a callback function. We present a mock up of what such a function would look like: </p><pre class="fragment">bool hitTestCallback(const NozVector&amp; origin, const NozVector&amp; dir, const double maxDist, PresenZ::RayTestResult&amp; out, void* userData)
{
   RayResult hitData;
   MyRenderer* renderer = static_cast&lt;MyRenderer*&gt;(userData);
   if(renderer-&gt;Trace(origin, dir, maxDist, &amp;hitData))
   {
       out.hit = hitData.location;
       out.normal = hitData.normal;
       out.d = hitData.distance;
       return true;
   }
   return false;
}
</pre><p>The hit test takes five arguments:</p>
<ul>
<li>An origin (typically the camera)</li>
<li>A direction</li>
<li>The maximum distance a ray is allowed to travel</li>
<li>A RayTestResult object in which the resulting hit information will be written if it is successful</li>
<li>A user data pointer that you may use as you wish</li>
</ul>
<p>In your function, you should call the render-specific “Trace” function and then convert the result into the <a class="el" href="namespace_presen_z.html">PresenZ</a> RayTestResult object. The callback returns whether or not something has been hit.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
4.1.3 Passing the hit test callback function to PresenZ</h3>
<p>Making <a class="el" href="namespace_presen_z.html">PresenZ</a> use your hitTestCallback function is done by passing it to the RayTestInterface. This interface is then used to evaluate each detection sample in PzProcessDetectSample().</p>
<pre class="fragment">RayTestInterface probe = { myUserDataPtr, hitTestCallback};

PzDetectSample sample;
// Set the parameters of the current sample being evaluated.
// …

PzProcessDetectSample(&amp;probe, sample);
</pre><h1><a class="anchor" id="autotoc_md27"></a>
4.2 Render phase</h1>
<p>The Render Phase follows the Detection Pass and shades all of the detection samples. Again, we present an overview of what should happen in your plugin for the Render Phase:</p>
<div class="image">
<img src="renderPhase.png" alt=""/>
<div class="caption">
Render Phase Overview</div></div>
    <h2><a class="anchor" id="autotoc_md28"></a>
4.2.1 Requirements</h2>
<p>It is important to note that for the Render Phase it is possible that there are more points to shade than the current render resolution allows. To resolve this, it should be possible to call multiple renders one after another. That way, we can spread the points over multiple renders, called “blocks”. Additionally, it has to be possible to shade a target from a custom viewpoint. This is especially important when rendering stereoscopic images, where we have to “bend rays” to align with the left and right eye view respectively.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
4.2.2 Casting Render Rays</h2>
<p>Similarly to the Detection Phase, we now need to cast the render rays. A function is provided called PzGetRayRenderPhase() that will return a PzCameraRay given a pixel coordinates on the target image.</p>
<pre class="fragment">PresenZ::Camera::PzCameraRay rayInfos;
rayInfos = PresenZ::Camera::PzGetRayRenderPhase(pixelX, pixelY);
</pre><p>As an option, you can call PzGetSamplingPos() to get a random sample location within a pixel. This function needs a seed value, which can either be created through our PzGetSeed() method or through your own render specific seed generator. This seed is a value used for generating the random locations of the samples within a pixel. Ensuring random sampling is important to guarantee a good final result for the pixel. Just as before, you should call PzGetCurrentSampleIndexCount() before casting each ray. Below is presented an example implementation.</p>
<pre class="fragment">const NozUInt64 seed = PresenZ::Camera::PzGetSeed(pixelX, pixelY);
size_t pixelSampleIndex = 0;
if (PresenZ::Camera::PzGetCurrentSampleIndexCount(pixelX, pixelY, pixelSampleIndex)) {
        NozVector2 xy = PresenZ::Camera::PzGetSamplingPos(seed, pixelSampleIndex);
        const double fpixelX = pixelX + xy.x;
        const double fpixelY = pixelY + xy.y;
        rayInfos = PresenZ::Camera::PzGetRayRenderPhase(fpixelX, fpixelY);
}
</pre><h2><a class="anchor" id="autotoc_md30"></a>
4.2.3 Shading the Render Rays</h2>
<p>After casting the render rays, the samples need to be shaded. Typically shading the samples is done from the camera position, unless you are rendering a stereoscopic image (in that case, you need to bend the rays to the correct eye position before shading, this is explained in section 7). Forward all the ray information to your render engine and execute your shading function:</p>
<pre class="fragment">//Forward the ray data to your render engine
engineRay.direction = presenzRay.direction;
engineRay.dDdx  = presenzRay.dDdx;
engineRay.dDdy  = presenzRay.dDdy;
engineRay.hitDistance  = presenzRay.hitDistance;
engineRay.origin  = presenzRay.origin;
engineRay.normal = presenzRay.normal;
//Call your render engine shading function
shade(engineRay);
</pre> <h2><a class="anchor" id="autotoc_md31"></a>
4.2.4 Forwarding the shaded pixels to PresenZ</h2>
<p><a class="el" href="namespace_presen_z.html">PresenZ</a> supports <b>two different modes</b> for forwarding shaded samples. The mode is selected at initialization with "" "`PzSetPresenZBucket()`".</p>
<ul>
<li><b>Bucket mode ON</b> (<code>PzSetPresenZBucket(true)</code>) <br  />
 Use the <em>immediate push</em> API PzProcessRenderSample() to send each shaded sample as soon as it is produced.</li>
<li><b>Bucket mode OFF</b> (<code>PzSetPresenZBucket(false)</code>) <br  />
 Use the <em>batch flush</em> API PzFlushSamplesToFile() to periodically write a collection of samples for a set of pixels (for example, at the end of a tile/bucket in Arnold).</li>
</ul>
<p>Both methods co-exist; choose the one that matches your renderer’s integration model.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
Bucket Mode ON</h3>
<pre class="fragment">//Create a PzRenderSample object
PzRenderSample winSample;
//Set all the samples data
for (int i = 0; i &lt; numSamples; i++) {
    PzSetSamplePosition(winSample, pos);
    PzSetSampleNormal(winSample, normal);
    PzSetSampleZ(winSample, Zvalue);
    PzSetSampleDepth(winSample, currentDepth);
    PzSetSamplePosXY(winSample, x, y);
    PzSetSampleColor(winSample, rgba);
    //Add the pixel sample to PresenZ
    PzProcessRenderSample(bucketId, x, y, winSample);
}
</pre> <blockquote class="doxtable">
<p>&zwj;The bucketId parameter is explained in chapter 5.</p>
<p></p>
</blockquote>
<p>### Bucket Mode OFF </p><pre class="fragment">// Create a list of the samples.
 std::vector&lt;PzRenderSample&gt; renderSamples;
PzRenderSample winSample;
//Set all the samples data
for (int i = 0; i &lt; numSamples; i++) {
    PzSetSamplePosition(winSample, pos);
    PzSetSampleNormal(winSample, normal);
    PzSetSampleZ(winSample, Zvalue);
    PzSetSampleDepth(winSample, currentDepth);
    PzSetSamplePosXY(winSample, x, y);
    PzSetSampleColor(winSample, rgba);     
    // Add it to the list
    renderSamples.push_back(winSample);
// Filter them 
std::vector&lt;PresenZ::RenderSample::PzFilteredSample&gt;  filteredSamples;
PzFilterRenderSample(x, y, renderSamples, filteredSamples);
</pre> <blockquote class="doxtable">
<p>&zwj;What to do with these filteredSamples is explained in chapter 5. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md33"></a>
4.2.5 Forwarding AOVs to PresenZ</h2>
<p>In the case that you declared AOVs for the sampling, you should also forward these to the PzRenderSample objects. This can be done by looping over the total number of AOVs and adding them to the PzRenderSample. AOVs vector before calling PzProcessRenderSample().</p>
<pre class="fragment">//aovFormat is a render engine dependent vector containing the AOV data.

for(int i = 0; i &lt; numAOVs; i++){
    AOVData&amp; aov = winSample.AOVs[i];
    if(aovFormat[i].type == BOOL){
        PresenZ::Ctx::BOOL: aov.b = ...; //get boolean value from aovFormat[i]
    if(aovFormat[i].type == INT){
        PresenZ::Ctx::INT: aov.d = ...;  //get integer value from aovFormat[i]
    //... other AOVs
}
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>PresenZ SDK: Detection phase and render phase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PresenZ SDK
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_presenz_jk_workspace__presen_z__s_d_k__linux_master@2_resources__s_d_k_manual_04-phases.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Detection phase and render phase </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>4.1 Detection phase</h1>
<p>The Detection Phase will identify which parts of the scene are viewable from within the Zone Of View and will return a przDetect file that is necessary to execute the Render Phase. Below, an overview is given of the several calls your plugin will need to make to let the Render Engine work with <a class="el" href="namespace_presen_z.html">PresenZ</a>.</p>
<div class="image">
<img src="detectPhase.png" alt="detectPhase.png"/>
<div class="caption">
Detection Phase Overview</div></div>
<h2>4.1.1 Requirements</h2>
<p>As previously mentioned in Section 2, the first phase must issue exactly 256 samples per pixel. <a class="el" href="namespace_presen_z.html">PresenZ</a> will require a small implementation (callback) that can check whether there is a line of sight between two points. To be more specific, this callback is used to check if scene geometry is visible from a certain camera .</p>
<h2>4.1.2 Casting Detection Rays</h2>
<p>When rendering the detection phase we need to go over every pixel in the image and launch a ray for it with <a class="el" href="group___pz_camera_api.html#ga67ee4eaa971ac94723bf28b77a3cbd29" title="Return a ray for a given pixel X/Y coordinate during the Detection Phase. ">PzGetRayDetectPhase()</a>. It is necessary to request the camera origin/direction for each pixel on the target image. This is usually done in the implementation of the camera. To help keep track of the sample index count - an internal counter of <a class="el" href="namespace_presen_z.html">PresenZ</a> that tells us how many of the 256 samples we have cast for a pixel- you should also call PzGetCurrentSampleIndexCount() beforehand. An example is presented below:</p>
<pre class="fragment">const int x = static_cast&lt;int&gt;(pixelX), y = static_cast&lt;int&gt;(pixelY);
size_t pixelSampleIndex = 0;
PresenZ::Camera::PzGetCurrentSampleIndexCount(x, y, pixelSampleIndex)
PresenZ::Camera::PzCameraRay rayCtx =
      PresenZ::Camera::PzGetRayDetectPhase(pixelSampleIndex, pixelX,
           pixelY);
</pre><p>After getting the ray context for a pixel, the data it contains should be forwarded to the ray structure of your current render engine.</p>
<pre class="fragment">struct PzCameraRay
{
    inline PzCameraRay() : valid(false) {}
    bool valid;      // True if the ray should be cast, False if the ray can be
                        discarded.
    NozVector origin; // ray origin
    NozVector dir;   // ray direction
    NozVector dDdx;  // ray direction derivatives with respect to x
    NozVector dDdy;  // ray direction derivatives with respect to y
};
</pre><h2>4.1.3 Creating a hit test callback function</h2>
<p>To check whether a point B is visible from point A, a hit test function needs to be created. This function is render engine dependent and needs to be given to <a class="el" href="namespace_presen_z.html">PresenZ</a> as a callback function. We present a mock up of what such a function would look like: </p>
<pre class="fragment">bool hitTestCallback(const NozVector&amp; origin, const NozVector&amp; dir, const double maxDist, PresenZ::RayTestResult&amp; out, void* userData)
{
   RayResult hitData;
   MyRenderer* renderer = static_cast&lt;MyRenderer*&gt;(userData);
   if(renderer-&gt;Trace(origin, dir, maxDist, &amp;hitData))
   {
       out.hit = hitData.location;
       out.normal = hitData.normal;
       out.d = hitData.distance;
       return true;
   }
   return false;
}
</pre><p>The hit test takes five arguments:</p>
<ul>
<li>An origin (typically the camera)</li>
<li>A direction</li>
<li>The maximum distance a ray is allowed to travel</li>
<li>A RayTestResult object in which the resulting hit information will be written if it is successful</li>
<li>A user data pointer that you may use as you wish</li>
</ul>
<p>In your function, you should call the render-specific “Trace” function and then convert the result into the <a class="el" href="namespace_presen_z.html">PresenZ</a> RayTestResult object. The callback returns whether or not something has been hit.</p>
<h3>4.1.3 Passing the hit test callback function to <a class="el" href="namespace_presen_z.html">PresenZ</a></h3>
<p>Making <a class="el" href="namespace_presen_z.html">PresenZ</a> use your hitTestCallback function is done by passing it to the RayTestInterface. This interface is then used to evaluate each detection sample in <a class="el" href="group___pz_detect_sample_api.html#ga0cca44a660fba1c326e072afabdb2d9a" title="During the detection phase, ray intersections need to be notified to PresenZ through PzProcessDetectS...">PzProcessDetectSample()</a>.</p>
<pre class="fragment">RayTestInterface probe = { myUserDataPtr, hitTestCallback, 0};

PzDetectSample sample;
// Set the parameters of the current sample being evaluated.
// …

PzProcessDetectSample(&amp;probe, sample, threadIndex);
</pre><h1>4.2 Render phase</h1>
<p>The Render Phase follows the Detection Pass and shades all of the detection samples. Again, we present an overview of what should happen in your plugin for the Render Phase:</p>
<div class="image">
<img src="renderPhase.png" alt="renderPhase.png"/>
<div class="caption">
Render Phase Overview</div></div>
 <h2>4.2.1 Requirements</h2>
<p>It is important to note that for the Render Phase it is possible that there are more points to shade than the current render resolution allows. To resolve this, it should be possible to call multiple renders one after another. That way, we can spread the points over multiple renders, called “blocks”. Additionally, it has to be possible to shade a target from a custom viewpoint. This is especially important when rendering stereoscopic images, where we have to “bend rays” to align with the left and right eye view respectively.</p>
<h2>4.2.2 Casting Render Rays</h2>
<p>Similarly to the Detection Phase, we now need to cast the render rays. A function is provided called <a class="el" href="group___pz_camera_api.html#ga08099ed3df3443530d6e9d05efb0d833" title="Return a rendering ray according to pixel X/Y coordinate in screen space. ">PzGetRayRenderPhase()</a> that will return a PzCameraRay given a pixel coordinates on the target image.</p>
<pre class="fragment">PresenZ::Camera::PzCameraRay rayInfos;
rayInfos = PresenZ::Camera::PzGetRayRenderPhase(pixelX, pixelY);
</pre><p>As an option, you can call PzGetSamplingPos() to get a random sample location within a pixel. This function needs a seed value, which can either be created through our <a class="el" href="group___pz_camera_api.html#ga95b7d9efef9cbb256104f216d559a24a" title="Given a screen position (X,Y), this will return a random seed. ">PzGetSeed()</a> method or through your own render specific seed generator. This seed is a value used for generating the random locations of the samples within a pixel. Ensuring random sampling is important to guarantee a good final result for the pixel. Just as before, you should call PzGetCurrentSampleIndexCount() before casting each ray. Below is presented an example implementation.</p>
<pre class="fragment">const NozUInt64 seed = PresenZ::Camera::PzGetSeed(pixelX, pixelY);
size_t pixelSampleIndex = 0;
if (PresenZ::Camera::PzGetCurrentSampleIndexCount(pixelX, pixelY, pixelSampleIndex)) {
        NozVector2 xy = PresenZ::Camera::PzGetSamplingPos(seed, pixelSampleIndex);
        const double fpixelX = pixelX + xy.x;
        const double fpixelY = pixelY + xy.y;
        rayInfos = PresenZ::Camera::PzGetRayRenderPhase(fpixelX, fpixelY);
}
</pre><h2>4.2.3 Shading the Render Rays</h2>
<p>After casting the render rays, the samples need to be shaded. Typically shading the samples is done from the camera position, unless you are rendering a stereoscopic image (in that case, you need to bend the rays to the correct eye position before shading, this is explained in section 7). Forward all the ray information to your render engine and execute your shading function:</p>
<pre class="fragment">//Forward the ray data to your render engine
engineRay.direction = presenzRay.direction;
engineRay.dDdx  = presenzRay.dDdx;
engineRay.dDdy  = presenzRay.dDdy;
engineRay.hitDistance  = presenzRay.hitDistance;
engineRay.origin  = presenzRay.origin;
engineRay.normal = presenzRay.normal;
//Call your render engine shading function
shade(engineRay);
</pre><h2>4.2.4 Forwarding the shaded pixels to <a class="el" href="namespace_presen_z.html">PresenZ</a></h2>
<p>Once all the pixels in a bucket have been sampled and shaded, we need to forward those shaded samples to <a class="el" href="namespace_presen_z.html">PresenZ</a>. First you will need to loop over each pixel in your bucket and then create an iterator that goes over the samples of that pixel. Below is a pseudo code example on how to process each pixel sample:</p>
<pre class="fragment">//Create a PzRenderSample object
PzRenderSample winSample;
//Set all the sample data
PzSetSamplePosition(winSample, pos);
PzSetSampleNormal(winSample, normal);
PzSetSampleZ(winSample, depth);
PzSetSamplePosXY(winSample, x, y);
PzSetSampleColor(winSample, rgba);
//Add the pixel sample to PresenZ
PzProcessRenderSample(bucketId, x, y, 0, winSample);
</pre><p>The bucketId parameter is explained in chapter 5.</p>
<h2>4.2.5 Forwarding AOVs to <a class="el" href="namespace_presen_z.html">PresenZ</a></h2>
<p>In the case that you declared AOVs for the sampling, you should also forward these to the PzRenderSample objects. This can be done by looping over the total number of AOVs and adding them to the PzRenderSample. AOVs vector before calling <a class="el" href="group___render_sample.html#gacbaf1537008aea01409b1eb1a220aa7b" title="Forward the current RenderSample data to PresenZ bucket. ">PzProcessRenderSample()</a>.</p>
<pre class="fragment">//aovFormat is a render engine dependent vector containing the AOV data.

for(int i = 0; i &lt; numAOVs; i++){
    AOVData&amp; aov = winSample.AOVs[i];
    if(aovFormat[i].type == BOOL){
        PresenZ::Ctx::BOOL: aov.b = ...; //get boolean value from aovFormat[i]
    if(aovFormat[i].type == INT){
        PresenZ::Ctx::INT: aov.d = ...;  //get integer value from aovFormat[i]
    //... other AOVs
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>

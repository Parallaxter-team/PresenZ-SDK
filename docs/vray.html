<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PresenZ SDK: Implementation in Vray</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PresenZ SDK
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vray.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Implementation in Vray </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_F__workspace_presenz_authoring_resources_SDK_manual_09_implementation_vray"></a> Here is the implementation code for <a class="el" href="namespace_presen_z.html">PresenZ</a> inside Chaos Group Vray.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
9.1 Camera</h1>
<h2><a class="anchor" id="autotoc_md45"></a>
9.1.1 presenz_camera.h</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef __PRESENZ_CAMERA_H__</span></div>
<div class="line"><span class="preprocessor">#define __PRESENZ_CAMERA_H__</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;presenz_sub_frames.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_pz_phase_api_8h.html">API/PzPhaseApi.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vraycam.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>PresenZSettings;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// PresenZ custom camera: Used to generate all the rays that PresenZ need to generate a volumetric image.</span></div>
<div class="line"><span class="keyword">class </span>PresenZCamera : <span class="keyword">public</span> VR::VRayCamera</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    PresenZCamera(PresenZSettings *pSettings);</div>
<div class="line">    <span class="keyword">virtual</span> ~PresenZCamera() {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> SetOldCamera(VR::VRayCamera* camera) { oldCamera = camera; }</div>
<div class="line">    <span class="keywordtype">bool</span> initSubFrames();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    int mapToScreen(const VR::ShadeVec&amp; p, VR::Vector2&amp; screenPt, double rayTime = 0., float dof_uc = 0.f, float dof_vc = 0.f) const;// { return false; }</span></div>
<div class="line"><span class="comment">    int mapToScreen(VR::VRayContext&amp; rc, VR::Vector2&amp; screenPt, float&amp; weight) const;// { return false; }</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, VR::TraceRay &amp;ray, VR::Ireal &amp;mint, VR::Ireal &amp;maxt, VR::RayDeriv &amp;rayDeriv, VR::ShadeCol &amp;multResult, uint32 flags) <span class="keyword">const</span> VRAY_OVERRIDE;</div>
<div class="line">    PluginInterface* newInterface(InterfaceID <span class="keywordtype">id</span>) VRAY_OVERRIDE;</div>
<div class="line">    VR::ShadeCol getExposure() const VRAY_OVERRIDE;</div>
<div class="line">    uint32 getFlags() const VRAY_OVERRIDE { <span class="keywordflow">return</span> VR::VRayCameraFlags::vrayCameraFlags_empty; }</div>
<div class="line">    <span class="keywordtype">void</span> renderBegin(VR::VRayRenderer *vray) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> renderEnd(VR::VRayRenderer *vray) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> frameBegin(VR::VRayRenderer *vray) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> frameEnd(VR::VRayRenderer *vray) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> frameBeginImpl(VR::VRayRenderer *vray, <span class="keyword">const</span> VR::VRaySequenceData &amp;sdata, <span class="keyword">const</span> VR::VRayFrameData &amp;fdata) VRAY_OVERRIDE;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> cube3x2_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, VR::TraceRay &amp;ray, VR::Ireal &amp;mint, VR::Ireal &amp;maxt, VR::RayDeriv &amp;rayDeriv, VR::ShadeCol &amp;multResult, uint32 flags) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">int</span> lightCache_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, VR::TraceRay &amp;ray, VR::Ireal &amp;mint, VR::Ireal &amp;maxt, VR::RayDeriv &amp;rayDeriv, VR::ShadeCol &amp;multResult, uint32 flags) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">int</span> detectPhase_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, VR::TraceRay &amp;ray, VR::Ireal &amp;mint, VR::Ireal &amp;maxt, VR::RayDeriv &amp;rayDeriv, VR::ShadeCol &amp;multResult, uint32 flags) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">int</span> renderPhase_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, VR::TraceRay &amp;ray, VR::Ireal &amp;mint, VR::Ireal &amp;maxt, VR::RayDeriv &amp;rayDeriv, VR::ShadeCol &amp;multResult, uint32 flags) <span class="keyword">const</span>;    </div>
<div class="line"> </div>
<div class="line">    PresenZSettings *presenZSettings;</div>
<div class="line">    VR::VRayCamera *oldCamera;</div>
<div class="line"> </div>
<div class="line">    VR::ShadeTransform camToWorld; <span class="comment">// The cached camera-to-world transformation.</span></div>
<div class="line">    VR::ShadeTransform worldToCam; <span class="comment">// The cached camera-to-world transformation.</span></div>
<div class="line">    PresenZSubFrames m_SubFrames;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// __PRESENZ_CAMERA_H__</span></div>
<div class="ttc" id="a_pz_phase_api_8h_html"><div class="ttname"><a href="_pz_phase_api_8h.html">PzPhaseApi.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
9.1.2 presenz_camera.cpp</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;presenz_camera.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;presenz_settings.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;presenz_sub_frames.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_camera_api_8h.html">API/PzCameraApi.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>VR;</div>
<div class="line"><span class="keyword">inline</span> simd::Vector3f ToVector3f(<span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozPoint</a>&amp; p) { <span class="keywordflow">return</span> simd::Vector3f(p.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, p.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, p.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>); }</div>
<div class="line"> </div>
<div class="line">PresenZCamera::PresenZCamera(PresenZSettings* pSettings): </div>
<div class="line">presenZSettings(pSettings),</div>
<div class="line">m_SubFrames(pSettings)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">PluginInterface* PresenZCamera::newInterface(InterfaceID <span class="keywordtype">id</span>) </div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == EXT_CAMERA_SUBFRAMES ) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>VR::VRayCameraSubFrames*<span class="keyword">&gt;</span>(&amp;m_SubFrames);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">int PresenZCamera::mapToScreen(const ShadeVec&amp; p, Vector2&amp; screenPt, double rayTime , float dof_uc, float dof_vc) const {</span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">    ShadeVec wpd = ShadeVec(p.x(), p.y(), p.z());</span></div>
<div class="line"><span class="comment">    ShadeVec pCSd = worldToCam * wpd;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    NozPoint ptCS(pCSd.x(), pCSd.y(), pCSd.z());</span></div>
<div class="line"><span class="comment">    NozPoint specPtCS = 100.0 * presenZSettings-&gt;specularPointOffset * presenZSettings-&gt;boxScaling / presenZSettings-&gt;renderScale;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    NozPoint ptFromSpec = NozVecNormalize(ptCS - specPtCS);</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    double u, v;</span></div>
<div class="line"><span class="comment">    PresenZ::Camera::PzGetUVFromRay(ptFromSpec, u, v);</span></div>
<div class="line"><span class="comment">    screenPt.x = presenZSettings-&gt;imageResolutionX * u;</span></div>
<div class="line"><span class="comment">    screenPt.y = presenZSettings-&gt;imageResolutionY * v;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    return true; </span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">int PresenZCamera::mapToScreen(VRayContext&amp; rc, Vector2&amp; screenPt, float&amp; weight) const {</span></div>
<div class="line"><span class="comment">    return false; </span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This is the main callback from VRay when it queries a ray origin/direction for a given X/Y. </span></div>
<div class="line"><span class="comment">// The implementation may differ depending the current phase PresenZ/Vray is in:</span></div>
<div class="line"><span class="comment">//      Phase 1: detection phase (will probe the geometry around the camera)</span></div>
<div class="line"><span class="comment">//      Phase 2-A: vray is generating the light cache (for faster shading)</span></div>
<div class="line"><span class="comment">//      Phase 2-B: rendering phase (will color the geometry found in step 1)</span></div>
<div class="line"><span class="keywordtype">int</span> PresenZCamera::getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, VR::TraceRay &amp;ray, VR::Ireal &amp;mint, VR::Ireal &amp;maxt, VR::RayDeriv &amp;rayDeriv, VR::ShadeCol &amp;multResult, uint32 flags)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    mint = 0.0f; <span class="comment">//  * Resolved Issue: the message &quot;Warning: Invalid geometric normal &lt;-0 -0 -0&gt; &quot; was thrown during detection phase.</span></div>
<div class="line">    maxt = 0.0f;</div>
<div class="line">    multResult.set(0.0f, 0.0f, 0.0f);</div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == justAFlatCubeMapRender ) {</div>
<div class="line">        <span class="keywordflow">return</span> cube3x2_getScreenRay(xs, ys, time, rnds, numRnds, ray, mint, maxt, rayDeriv, multResult, flags);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// VRAY FREEZE HACK</span></div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;makeInvisibleLight == 5 &amp;&amp; (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a48a95ceab76284afa466622424eba555">PresenZ::Phase::Detect</a> || presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::Detect_Reflection</a>) )</div>
<div class="line">        <span class="keywordflow">return</span> 0; </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// even if frame has not begun, the light can be computed by vray. and this will cause problem </span></div>
<div class="line">    <span class="comment">// because PresenZ has not phase begun.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!presenZSettings-&gt;hasFrameBegun) </div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!presenZSettings-&gt;lightCacheDone)</div>
<div class="line">        <span class="keywordflow">return</span> lightCache_getScreenRay(xs, ys, time, rnds, numRnds, ray, mint, maxt, rayDeriv, multResult, flags);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84ac677a954de25220db675695edacb4f71">PresenZ::Phase::Render</a> || presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a>) <span class="comment">// all cams hole rendering </span></div>
<div class="line">        <span class="keywordflow">return</span> renderPhase_getScreenRay(xs, ys, time, rnds, numRnds, ray, mint, maxt, rayDeriv, multResult, flags);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> detectPhase_getScreenRay(xs, ys, time, rnds, numRnds, ray, mint, maxt, rayDeriv, multResult, flags);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes a ray for the given pixel coordinates. Result must be in world space using the provided camera to world space transform.</span></div>
<div class="line"><span class="comment">// Return true to trace the camera ray and false to skip it.</span></div>
<div class="line"><span class="keywordtype">int</span> PresenZCamera::lightCache_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, TraceRay &amp;ray, Ireal &amp;mint, Ireal &amp;maxt, RayDeriv &amp;rayDeriv, ShadeCol &amp;multResult, uint32 flags)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html">PresenZ::Camera::PzCameraRay</a> rayGI = <a class="code" href="group___pz_camera_api.html#ga886f1b22774afe58b527b98b10e26c3a">PresenZ::Camera::PzGetSpecularRay</a>(xs, ys);</div>
<div class="line"> </div>
<div class="line">    ray.set(camToWorld*ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a3e1a826396726caf4930542970259fef">origin</a>), camToWorld.m*ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2. / (presenZSettings-&gt;imageResolutionX );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2. / (presenZSettings-&gt;imageResolutionY );</div>
<div class="line">    rayDeriv.dDdx = camToWorld.m * ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>);</div>
<div class="line">    rayDeriv.dDdy = camToWorld.m * ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>);</div>
<div class="line">    rayDeriv.dDdx *= dx;</div>
<div class="line">    rayDeriv.dDdy *= dy;</div>
<div class="line">    rayDeriv.dPdx.makeZero();</div>
<div class="line">    rayDeriv.dPdy.makeZero();</div>
<div class="line"> </div>
<div class="line">    multResult.set(1.0f, 1.0f, 1.0f);</div>
<div class="line">    mint = 0.0f;</div>
<div class="line">    maxt = LARGE_FLOAT;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> PresenZCamera::cube3x2_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, TraceRay &amp;ray, Ireal &amp;mint, Ireal &amp;maxt, RayDeriv &amp;rayDeriv, ShadeCol &amp;multResult, uint32 flags)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html">PresenZ::Camera::PzCameraRay</a> rayGI = <a class="code" href="group___pz_camera_api.html#gaa1864ca91f071751a146c69a74428f38">PresenZ::Camera::PzGetCenterRay</a>(xs, ys, presenZSettings-&gt;imageResolutionX, presenZSettings-&gt;imageResolutionY);</div>
<div class="line"> </div>
<div class="line">    ray.set(camToWorld*ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a3e1a826396726caf4930542970259fef">origin</a>), camToWorld.m*ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2. / (presenZSettings-&gt;imageResolutionX );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2. / (presenZSettings-&gt;imageResolutionY );</div>
<div class="line">    rayDeriv.dDdx = camToWorld.m * ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>);</div>
<div class="line">    rayDeriv.dDdy = camToWorld.m * ToVector3f(rayGI.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>);</div>
<div class="line">    rayDeriv.dDdx *= dx;</div>
<div class="line">    rayDeriv.dDdy *= dy;</div>
<div class="line">    rayDeriv.dPdx.makeZero();</div>
<div class="line">    rayDeriv.dPdy.makeZero();</div>
<div class="line"> </div>
<div class="line">    multResult.set(1.0f, 1.0f, 1.0f);</div>
<div class="line">    mint = 0.0f;</div>
<div class="line">    maxt = LARGE_FLOAT;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes a ray during detection phase. PresenZ returns a ray direction in local coordinates and this function will </span></div>
<div class="line"><span class="comment">// transform these into global coordinates. It will also take the sample index as input. Vray does not track the sample </span></div>
<div class="line"><span class="comment">// index in the camera. As a helper, PzGetCurrentSampleIndexCount can be invoked to get a simple sample counter for a given X/Y pixel.</span></div>
<div class="line"><span class="keywordtype">int</span> PresenZCamera::detectPhase_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, TraceRay &amp;ray, Ireal &amp;mint, Ireal &amp;maxt, RayDeriv &amp;rayDeriv, ShadeCol &amp;multResult, uint32 flags)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{  </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html">PresenZ::Camera::PzCameraRay</a> detectRay = <a class="code" href="group___pz_camera_api.html#ga2eb896736291c40c72f66d8a7591dc12">PresenZ::Camera::PzGetCameraRay</a>(xs, ys); <span class="comment">//camera space ray;</span></div>
<div class="line">    <span class="keywordflow">if</span> (!detectRay.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a28e3c179a86f337095088b3ca02a2b2a">valid</a>)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    ray.set(camToWorld*ToVector3f(detectRay.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a3e1a826396726caf4930542970259fef">origin</a>), camToWorld.m*ToVector3f(detectRay.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2. / (presenZSettings-&gt;imageResolutionX );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2. / (presenZSettings-&gt;imageResolutionY );</div>
<div class="line">    rayDeriv.dDdx = camToWorld.m * ToVector3f(detectRay.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>);</div>
<div class="line">    rayDeriv.dDdy = camToWorld.m * ToVector3f(detectRay.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>);</div>
<div class="line">    rayDeriv.dDdx *= dx;</div>
<div class="line">    rayDeriv.dDdy *= dy;</div>
<div class="line">    rayDeriv.dPdx.makeZero();</div>
<div class="line">    rayDeriv.dPdy.makeZero();</div>
<div class="line"> </div>
<div class="line">    multResult.set(1.0f, 1.0f, 1.0f);</div>
<div class="line">    mint = 0.0f;</div>
<div class="line">    maxt = LARGE_FLOAT;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compute a ray origin/direction during rendering phase. Similarly to the Detection Phase, PresenZ will return ray coordinates in local space. </span></div>
<div class="line"><span class="comment">// You do not need to provide the sample index during the render phase.</span></div>
<div class="line"><span class="keywordtype">int</span> PresenZCamera::renderPhase_getScreenRay(<span class="keywordtype">double</span> xs, <span class="keywordtype">double</span> ys, <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">float</span> *rnds, <span class="keywordtype">int</span> numRnds, TraceRay &amp;ray, Ireal &amp;mint, Ireal &amp;maxt, RayDeriv &amp;rayDeriv, ShadeCol &amp;multResult, uint32 flags)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{       </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html">PresenZ::Camera::PzCameraRay</a> rayRender = <a class="code" href="group___pz_camera_api.html#ga2eb896736291c40c72f66d8a7591dc12">PresenZ::Camera::PzGetCameraRay</a>(xs, ys);</div>
<div class="line">    <span class="keywordflow">if</span> (!rayRender.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a28e3c179a86f337095088b3ca02a2b2a">valid</a>)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    ray.set(camToWorld*ToVector3f(rayRender.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a3e1a826396726caf4930542970259fef">origin</a>), camToWorld.m*ToVector3f(rayRender.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>));</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2. / (presenZSettings-&gt;imageResolutionX );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2. / (presenZSettings-&gt;imageResolutionY );</div>
<div class="line">    rayDeriv.dDdx = camToWorld.m * ToVector3f(rayRender.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>);</div>
<div class="line">    rayDeriv.dDdy = camToWorld.m * ToVector3f(rayRender.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>);</div>
<div class="line">    rayDeriv.dDdx *= dx;</div>
<div class="line">    rayDeriv.dDdy *= dy;</div>
<div class="line"> </div>
<div class="line">    rayDeriv.dPdx.makeZero();</div>
<div class="line">    rayDeriv.dPdy.makeZero();</div>
<div class="line"> </div>
<div class="line">    multResult.set(1.0f, 1.0f, 1.0f);</div>
<div class="line">    mint = rayRender.<a class="code" href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a10783e24924a7160fed76c3a48530298">minZ</a>; <span class="comment">//start shooting ray from this distance</span></div>
<div class="line"> </div>
<div class="line">    maxt = LARGE_FLOAT;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">VR::ShadeCol PresenZCamera::getExposure()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (oldCamera) <span class="keywordflow">return</span> oldCamera-&gt;getExposure();</div>
<div class="line">    <span class="keywordflow">return</span> VR::VRayCamera::getExposure();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZCamera::renderBegin(VRayRenderer *vray) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldCamera) oldCamera-&gt;renderBegin(vray);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZCamera::renderEnd(VRayRenderer *vray) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldCamera)  oldCamera-&gt;renderEnd(vray);</div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;oldPathSampler) {</div>
<div class="line">        presenZSettings-&gt;psdata-&gt;pathSampler = presenZSettings-&gt;oldPathSampler;</div>
<div class="line">        presenZSettings-&gt;oldPathSampler = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZCamera::frameBegin(VR::VRayRenderer *vray) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldCamera) oldCamera-&gt;frameBegin(vray);</div>
<div class="line">    camToWorld= vray-&gt;getFrameData().camToWorld;        </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    worldToCam = vray-&gt;getFrameData().worldToCam;</span></div>
<div class="line"><span class="comment">    NozMatrix camToWorldO = getNozM4Identity();</span></div>
<div class="line"><span class="comment">    nozMatrix_set(camToWorldO,</span></div>
<div class="line"><span class="comment">        camToWorld.m[0][0], camToWorld.m[0][1], camToWorld.m[0][2], 0.0,</span></div>
<div class="line"><span class="comment">        camToWorld.m[1][0], camToWorld.m[1][1], camToWorld.m[1][2], 0.0,</span></div>
<div class="line"><span class="comment">        camToWorld.m[2][0], camToWorld.m[2][1], camToWorld.m[2][2], 0.0,</span></div>
<div class="line"><span class="comment">        vray-&gt;getFrameData().sceneOffset.x + vray-&gt;getFrameData().camToWorld.offs.x(), </span></div>
<div class="line"><span class="comment">        vray-&gt;getFrameData().sceneOffset.y + vray-&gt;getFrameData().camToWorld.offs.y(),</span></div>
<div class="line"><span class="comment">        vray-&gt;getFrameData().sceneOffset.z + vray-&gt;getFrameData().camToWorld.offs.z(), 1.0);</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    PresenZ::Phase::PzSetCameraToWorldMatrix(camToWorldO);</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZCamera::frameEnd(VRayRenderer *vray) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldCamera) oldCamera-&gt;frameEnd(vray);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZCamera::frameBeginImpl(VR::VRayRenderer *vray, <span class="keyword">const</span> VR::VRaySequenceData &amp;sdata, <span class="keyword">const</span> VR::VRayFrameData &amp;fdata) {</div>
<div class="line">    frameBegin(vray);</div>
<div class="line">    <span class="keywordflow">if</span> (oldCamera)</div>
<div class="line">        oldCamera-&gt;frameBegin(vray);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZCamera::initSubFrames(){</div>
<div class="line">    <span class="keywordflow">return</span> m_SubFrames.initSubFrames();</div>
<div class="line">}</div>
<div class="ttc" id="a_pz_camera_api_8h_html"><div class="ttname"><a href="_pz_camera_api_8h.html">PzCameraApi.h</a></div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_gaa4f0d3eebc3c443f9be81bf48561a217"><div class="ttname"><a href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">NozPoint::y</a></div><div class="ttdeci">float y</div><div class="ttdoc">y</div><div class="ttdef"><b>Definition:</b> vector.h:29</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_gad0da36b2558901e21e7a30f6c227a45e"><div class="ttname"><a href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">NozPoint::x</a></div><div class="ttdeci">float x</div><div class="ttdoc">x</div><div class="ttdef"><b>Definition:</b> vector.h:27</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_gaf73583b1e980b0aa03f9884812e9fd4d"><div class="ttname"><a href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">NozPoint::z</a></div><div class="ttdeci">float z</div><div class="ttdoc">z</div><div class="ttdef"><b>Definition:</b> vector.h:31</div></div>
<div class="ttc" id="agroup___pz_camera_api_html_ga2eb896736291c40c72f66d8a7591dc12"><div class="ttname"><a href="group___pz_camera_api.html#ga2eb896736291c40c72f66d8a7591dc12">PresenZ::Camera::v3_0::PzGetCameraRay</a></div><div class="ttdeci">PzCameraRay PzGetCameraRay(const double &amp;x, const double &amp;y)</div><div class="ttdoc">Return a ray for a given pixel X/Y coordinate for the current PresenZ phase.</div></div>
<div class="ttc" id="agroup___pz_camera_api_html_ga886f1b22774afe58b527b98b10e26c3a"><div class="ttname"><a href="group___pz_camera_api.html#ga886f1b22774afe58b527b98b10e26c3a">PresenZ::Camera::v3_0::PzGetSpecularRay</a></div><div class="ttdeci">PzCameraRay PzGetSpecularRay(const double &amp;x, const double &amp;y)</div><div class="ttdoc">Return a ray as if it was cast from the specularPoint of the camera.</div></div>
<div class="ttc" id="agroup___pz_camera_api_html_gaa1864ca91f071751a146c69a74428f38"><div class="ttname"><a href="group___pz_camera_api.html#gaa1864ca91f071751a146c69a74428f38">PresenZ::Camera::v3_0::PzGetCenterRay</a></div><div class="ttdeci">PzCameraRay PzGetCenterRay(const double &amp;x, const double &amp;y, const double &amp;xres, double &amp;yres)</div><div class="ttdoc">Return a ray as if it was cast from the center of the camera.</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_ggae1c5184dc404edf057ed537bcfddef84a48a95ceab76284afa466622424eba555"><div class="ttname"><a href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a48a95ceab76284afa466622424eba555">PresenZ::Phase::v3_0::Detect</a></div><div class="ttdeci">@ Detect</div><div class="ttdoc">Detection phase.</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:71</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e"><div class="ttname"><a href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::v3_0::Render_Reflection</a></div><div class="ttdeci">@ Render_Reflection</div><div class="ttdoc">Detection phase for reflections.</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:77</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c"><div class="ttname"><a href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::v3_0::Detect_Reflection</a></div><div class="ttdeci">@ Detect_Reflection</div><div class="ttdoc">Detection phase for reflections.</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:75</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_ggae1c5184dc404edf057ed537bcfddef84ac677a954de25220db675695edacb4f71"><div class="ttname"><a href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84ac677a954de25220db675695edacb4f71">PresenZ::Phase::v3_0::Render</a></div><div class="ttdeci">@ Render</div><div class="ttdoc">Render phase.</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:73</div></div>
<div class="ttc" id="astruct_noz_point_html"><div class="ttname"><a href="struct_noz_point.html">NozPoint</a></div><div class="ttdoc">3D point (single precision)</div><div class="ttdef"><b>Definition:</b> vector.h:25</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html">PresenZ::Camera::v3_0::PzCameraRay</a></div><div class="ttdoc">PzCameraRay defines the return value from PzGetRayDetectPhase() / PzGetRayRenderPhase() containing da...</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:47</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html_a10783e24924a7160fed76c3a48530298"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a10783e24924a7160fed76c3a48530298">PresenZ::Camera::v3_0::PzCameraRay::minZ</a></div><div class="ttdeci">float minZ</div><div class="ttdoc">ray strating distance from the origin.</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:60</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html_a28e3c179a86f337095088b3ca02a2b2a"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a28e3c179a86f337095088b3ca02a2b2a">PresenZ::Camera::v3_0::PzCameraRay::valid</a></div><div class="ttdeci">bool valid</div><div class="ttdoc">True if the ray should be cast, False if the ray can be discarded.</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:50</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html_a3e1a826396726caf4930542970259fef"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a3e1a826396726caf4930542970259fef">PresenZ::Camera::v3_0::PzCameraRay::origin</a></div><div class="ttdeci">NozPoint origin</div><div class="ttdoc">ray origin</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:52</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html_a736153c8076e6040f9703e238e5b987c"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a736153c8076e6040f9703e238e5b987c">PresenZ::Camera::v3_0::PzCameraRay::dDdx</a></div><div class="ttdeci">NozVector dDdx</div><div class="ttdoc">ray direction derivatives with respect to the x of target image</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:56</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html_a7d4ae5b50b35b0b0e860ffe3192b05da"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">PresenZ::Camera::v3_0::PzCameraRay::dir</a></div><div class="ttdeci">NozVector dir</div><div class="ttdoc">ray direction</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:54</div></div>
<div class="ttc" id="astruct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray_html_aeb84bfd699fd4a7c535d38f19449e6b4"><div class="ttname"><a href="struct_presen_z_1_1_camera_1_1v3__0_1_1_pz_camera_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">PresenZ::Camera::v3_0::PzCameraRay::dDdy</a></div><div class="ttdeci">NozVector dDdy</div><div class="ttdoc">ray direction derivatives with respect to the y of target image</div><div class="ttdef"><b>Definition:</b> PzCameraApi.h:58</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md47"></a>
9.2 Intersection shader</h1>
<h2><a class="anchor" id="autotoc_md48"></a>
9.2.1 presenz_intersection_shader.h</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef __PRESENZ_INTERSECTION_SHADER_H__</span></div>
<div class="line"><span class="preprocessor">#define __PRESENZ_INTERSECTION_SHADER_H__</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;vrayinters_shaders.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vrayinterface.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="color_8h.html">common/color.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="vector_8h.html">common/vector.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_detect_sample_api_8h.html">API/PzDetectSampleApi.h</a>&quot;</span></div>
<div class="line"><span class="keyword">struct </span>PresenZSettings;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This class gathers the basic information from a ray cast that is triggered by PresenZIntersectionShader</span></div>
<div class="line"><span class="keyword">struct </span>RayTestResult</div>
<div class="line">{</div>
<div class="line">    RayTestResult();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozPoint</a> hitLocation;</div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> hitNormal;</div>
<div class="line">    <span class="keywordtype">double</span> hitDistance;</div>
<div class="line">    <span class="keywordtype">bool</span> hasHit;</div>
<div class="line">    <span class="keywordtype">bool</span> isChaotic;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> VrayTAGstrs[] = { <span class="stringliteral">&quot;prz_transp&quot;</span>, <span class="stringliteral">&quot;prz_glass_IOR&quot;</span>,<span class="stringliteral">&quot;prz_brdf_glass&quot;</span>, <span class="stringliteral">&quot;prz_chaotic&quot;</span>, <span class="stringliteral">&quot;prz_stereo&quot;</span>,<span class="stringliteral">&quot;prz_cockpit&quot;</span>,<span class="stringliteral">&quot;prz_isl&quot;</span>, <span class="stringliteral">&quot;prz_stencil&quot;</span> };</div>
<div class="line"><span class="keyword">enum</span> VrayTAGs {</div>
<div class="line">    VT_transp = 0,</div>
<div class="line">    VT_glassIOR = 1,</div>
<div class="line">    VT_glassbrdf = 2,</div>
<div class="line">    VT_chaotic = 3,</div>
<div class="line">    VT_stereo = 4,</div>
<div class="line">    VT_cockpit = 5,</div>
<div class="line">    VT_isolated = 6,</div>
<div class="line">    VT_stencil = 7,</div>
<div class="line">    VT_size = 8</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// tagging is not working for forest pack oject so I&#39;m using SSSid instead</span></div>
<div class="line"><span class="comment">// and this is the bit used for tagging </span></div>
<div class="line"><span class="keyword">enum</span> FP_SSSID_bit {</div>
<div class="line">    FSb_chaotic = 0,</div>
<div class="line">    FSb_isolated = 1,</div>
<div class="line">    FSb_stereo = 2,</div>
<div class="line">    FSb_glassIOR = 3,</div>
<div class="line">    FSb_glass = 4,</div>
<div class="line">    FSb_stencil = 5</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vray will invoke PresenZIntersectionShader::shade2 every time a camera ray hits a surface.</span></div>
<div class="line"><span class="comment">// This class will then dispatch the hit information to shadeDetectPhase/shadeEvalOpaque/shadeEvalTransparent.</span></div>
<div class="line"><span class="comment">// These methods will then gather the needed data and forward the hit detection to PresenZ.</span></div>
<div class="line"><span class="keyword">class </span>PresenZIntersectionShader : <span class="keyword">public</span> VR::VRayIntersectionShader2 {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    PresenZIntersectionShader(PresenZSettings *presenZSettings);</div>
<div class="line">    <span class="keyword">virtual</span> ~PresenZIntersectionShader() {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// hit callback from VRay</span></div>
<div class="line">    <span class="keywordtype">int</span> shade2(VR::VRayContext &amp;rc) VRAY_OVERRIDE;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Will be invoked by the plugin just before rendering so the shader can invoke the right method (shadeDetectPhase/shadeEvalOpaque/shadeEvalTransparent)</span></div>
<div class="line">    <span class="keywordtype">void</span> setupShadingMethods();             </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Callback invoked by PresenZ during Detection Phase to ensure a point in space is visible by additional viewpoints</span></div>
<div class="line">    RayTestResult RayTest(VR::VRayContext &amp;rc, <span class="keyword">const</span> VR::ShadeVec &amp;origin, <span class="keyword">const</span> VR::ShadeVec &amp;dir, <span class="keywordtype">double</span> maxDist) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// These shade methods will be invoked by shade2 </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Used during Detection Phase</span></div>
<div class="line">    <span class="keywordtype">void</span> shadeDetectPhase(VR::VRayContext &amp;rc);      <span class="comment">// perform geometry detection without coloring intersection. </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Used during Render Phase        </span></div>
<div class="line">    <span class="keywordtype">void</span> shadeEvalTransparent(VR::VRayContext &amp;rc);  <span class="comment">// will shade the intersection for a glass</span></div>
<div class="line">    <span class="keywordtype">void</span> shadeEvalTransparentBrdf(VR::VRayContext &amp;rc); <span class="comment">// will shade the intersection for a glass surface with a presenz glass material applied .</span></div>
<div class="line">    <span class="keywordtype">void</span> shadeEvalOpaque(VR::VRayContext &amp;rc);        <span class="comment">// will shade the intersection for an opaque surface</span></div>
<div class="line">    <span class="keywordtype">void</span> shadeEvalOpaqueAndTransparent(VR::VRayContext &amp;rc); </div>
<div class="line">    <span class="keywordtype">void</span> shadeEvalRenderReflection(VR::VRayContext &amp;rc);</div>
<div class="line">    <span class="keywordtype">void</span> shadeEvalStencil(VR::VRayContext &amp;rc, <a class="code" href="group___pz_detect_sample_api.html#ga4235bda2ada163773d83c4d1d6c75bc0">PresenZ::DetectSample::DetectSample_transp</a> qtransp);</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> shade_RENDERREFLECTIONRAY(VR::VRayContext &amp;rc);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Will notify PresenZ that we&#39;ve found a colored sample, with shaded false will notify PresenZ has not been shaded.</span></div>
<div class="line">    <span class="keywordtype">void</span> outputRenderSample(<span class="keyword">const</span> VR::VRayContext &amp;rc, <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> &amp;leftColor, <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> &amp;rightColor, <span class="keywordtype">float</span> alpha, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;shadeType, <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp;isMirror = <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// perform ray bending before the shading evaluation. (move the origin of the ray to center of the zov )</span></div>
<div class="line">    <span class="keywordtype">bool</span> bendCameraRay(VR::VRayContext &amp;rc, <span class="keywordtype">bool</span> rightEye);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This function will cast a new cam ray from the current transparent hit point.</span></div>
<div class="line">    <span class="comment">// The origin of the ray is the specular point, The startDistance is the current hit distance</span></div>
<div class="line">    <span class="comment">// The vray traceRay function inside will evaluate the shade in the path of the new ray and the return color </span></div>
<div class="line">    <span class="comment">// will be added to the rc.mtlResult current shade.</span></div>
<div class="line">    <span class="keywordtype">bool</span> traceCamRayForShadingTransparentSurface(VR::VRayContext &amp;rc, <span class="keywordtype">bool</span> rightEye);</div>
<div class="line">                                                                        </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> checkUserAttribute(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, <span class="keyword">const</span> VrayTAGs TAG, <span class="keywordtype">float</span> &amp;value) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fast surface queries for proper rendering. These methods quickly verify that the notified intersection needs shading.</span></div>
<div class="line">    <span class="keywordtype">bool</span> isPrzTranspSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    <span class="comment">//bool isNotPrzTranspSurface(const VR::VRayContext&amp; rc, const VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) const;</span></div>
<div class="line">    <span class="keywordtype">bool</span> isPrzGlassSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzChaoticSurface(VR::VRayContext&amp; rc, VR::IntersectionData &amp;isData) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzStencilSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzIsolatedSurface(VR::VRayContext&amp; rc, VR::IntersectionData &amp;isData) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzBrdfGlassSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    <span class="comment">//bool isNotPrzBrdfGlassSurface(const VR::VRayContext&amp; rc, const VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) const;</span></div>
<div class="line">    <span class="keywordtype">bool</span> isLightSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isTransparentLightSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzStereoRightEye(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzBrdf(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isPrzCockpit(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> isShadeTransp(<span class="keyword">const</span> VR::VRayContext &amp;rc, <span class="keyword">const</span> VR::ShadeVec &amp;pt, <span class="keyword">const</span> VR::ShadeVec &amp;dir, <span class="keywordtype">double</span> maxDist, <span class="keywordtype">float</span> rx, <span class="keywordtype">float</span> ry, <span class="keywordtype">float</span> &amp;transp) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// used to shade intersections according to the shading mode</span></div>
<div class="line">    <span class="keyword">typedef</span> void (PresenZIntersectionShader::* ShadingFunc)(VR::VRayContext &amp;rc);</div>
<div class="line">    ShadingFunc prz_shading;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> bool (PresenZIntersectionShader::*checkSurfaceFunc) (<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData&amp; isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;checkSurfaceFunc&gt;  checkSurfaceFuncArray;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stack of verification methods.</span></div>
<div class="line">    checkSurfaceFuncArray m_invisibleForCameraRay;</div>
<div class="line">    checkSurfaceFuncArray m_invisibleForProbeRay;</div>
<div class="line">    checkSurfaceFuncArray m_shadeable;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Returns true if one of the conditions (in functionContainer) is filled.</span></div>
<div class="line">    <span class="keywordtype">bool</span> checkIfSurfaceIs(<span class="keyword">const</span> PresenZIntersectionShader::checkSurfaceFuncArray &amp;functionContainer, <span class="keyword">const</span> VR::VRayContext &amp;rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable) <span class="keyword">const</span>;</div>
<div class="line">    PresenZSettings *presenZSettings;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// __PRESENZ_INTERSECTION_SHADER_H__</span></div>
<div class="ttc" id="a_pz_detect_sample_api_8h_html"><div class="ttname"><a href="_pz_detect_sample_api_8h.html">PzDetectSampleApi.h</a></div></div>
<div class="ttc" id="acolor_8h_html"><div class="ttname"><a href="color_8h.html">color.h</a></div></div>
<div class="ttc" id="agroup___pz_detect_sample_api_html_ga4235bda2ada163773d83c4d1d6c75bc0"><div class="ttname"><a href="group___pz_detect_sample_api.html#ga4235bda2ada163773d83c4d1d6c75bc0">PresenZ::DetectSample::v3_0::DetectSample_transp</a></div><div class="ttdeci">DetectSample_transp</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:73</div></div>
<div class="ttc" id="astruct_noz_r_g_b_html"><div class="ttname"><a href="struct_noz_r_g_b.html">NozRGB</a></div><div class="ttdoc">RGB color.</div><div class="ttdef"><b>Definition:</b> color.h:88</div></div>
<div class="ttc" id="avector_8h_html"><div class="ttname"><a href="vector_8h.html">vector.h</a></div><div class="ttdoc">Vector math types, operators and utilities.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
9.2.2 presenz_intersection_shader.cpp</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;presenz_intersection_shader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;presenz_settings.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;vrayVersion.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vraycolormapper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vraytexutils.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;vrutils.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_assert_8h.html">API/PzAssert.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_phase_api_8h.html">API/PzPhaseApi.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_shading_api_8h.html">API/PzShadingApi.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_render_sample_api_8h.html">API/PzRenderSampleApi.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define IFRCISMYPLAQUE if(false)</span></div>
<div class="line"><span class="comment">//#define IFRCISMYPLAQUE if(PresenZ::Phase::PzIsMyPlaque(rc.rayparams.getScreenX(), rc.rayparams.getScreenY(),134,209,404  ) )</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// #include &lt;windows.h&gt;</span></div>
<div class="line"><span class="comment">// #define DBGOUTPUT OutputDebugStringA(hit.c_str());</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vray added some ray flags between Vray 4.3 and vray 5.2</span></div>
<div class="line"><span class="comment">// Let&#39;s pick the last bit from the list for our private stuff </span></div>
<div class="line"><span class="preprocessor">#define RENDERREFLECTIONRAY (1ULL &lt;&lt; 63)</span></div>
<div class="line"><span class="preprocessor">#define PROBESHADE (1ULL &lt;&lt; 63)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <a class="code" href="struct_noz_point.html">NozVector</a> ToNozVector(<span class="keyword">const</span> VR::Vector&amp; p) { <span class="keywordflow">return</span> <a class="code" href="group___n_o_z__vector.html#ga347d85f3e636cf273a47949aa0613a8f">NozVector</a>(p.x, p.y, p.z); }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define VRAY_MAXRECURSION 50   </span><span class="comment">// the maximum number of surface a ray probe can go through</span></div>
<div class="line"><span class="keyword">using namespace </span>VR;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>RayTestInterfaceUserData</div>
<div class="line">{</div>
<div class="line">    RayTestInterfaceUserData(VUtils::VRayContext &amp;rc, PresenZIntersectionShader* shader) : m_rc(rc), m_shader(shader) {}</div>
<div class="line">    VUtils::VRayContext &amp;m_rc;</div>
<div class="line">    PresenZIntersectionShader* m_shader;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">uint64_t VRayQueryFlags(uint64_t flags, <span class="keywordtype">void</span>* userData);</div>
<div class="line"><span class="keywordtype">bool</span> VRayRayTest(<span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; origin, <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; dir, <span class="keyword">const</span> <span class="keywordtype">double</span> dist, <a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html">PresenZ::DetectSample::RayTestResult</a>&amp; out, <span class="keywordtype">void</span>* userData);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convert a string into a floating point number</span></div>
<div class="line"><span class="keywordtype">float</span> stor(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) {</div>
<div class="line">    <span class="keywordtype">float</span> result = 0;</div>
<div class="line">    <span class="keywordtype">float</span> sign = *str == <span class="charliteral">&#39;-&#39;</span> ? str++, -1 : 1;</div>
<div class="line">    <span class="keywordflow">while</span> (*str &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; *str &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line">        result *= 10;</div>
<div class="line">        result += *str - <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">        str++;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (*str == <span class="charliteral">&#39;,&#39;</span> || *str == <span class="charliteral">&#39;.&#39;</span>) {</div>
<div class="line">        str++;</div>
<div class="line">        <span class="keywordtype">float</span> multiplier = 0.1;</div>
<div class="line">        <span class="keywordflow">while</span> (*str &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; *str &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line">            result += (*str - <span class="charliteral">&#39;0&#39;</span>) * multiplier;</div>
<div class="line">            multiplier /= 10;</div>
<div class="line">            str++;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result *= sign;</div>
<div class="line">    <span class="keywordflow">if</span> (*str == <span class="charliteral">&#39;e&#39;</span> || *str == <span class="charliteral">&#39;E&#39;</span>) {</div>
<div class="line">        str++;</div>
<div class="line">        <span class="keywordtype">float</span> powerer = *str == <span class="charliteral">&#39;-&#39;</span> ? str++, 0.1 : 10;</div>
<div class="line">        <span class="keywordtype">float</span> power = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (*str &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; *str &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line">            power *= 10;</div>
<div class="line">            power += *str - <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">            str++;</div>
<div class="line">        }</div>
<div class="line">        result *= pow(powerer, power);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following structure will save the hit detection data on the stack. It will restore</span></div>
<div class="line"><span class="comment">// the data before returning the function. Useful helper if you change the context during shade.</span></div>
<div class="line"><span class="keyword">struct </span>AutoSaveRayContextData</div>
<div class="line">{</div>
<div class="line">    AutoSaveRayContextData(VR::VRayContext &amp;rc) :</div>
<div class="line">        m_rc(rc),</div>
<div class="line">        m_wpointCoeff(rc.rayresult.wpointCoeff),</div>
<div class="line">        m_rayTracedDir(rc.rayparams.tracedRay.dir),</div>
<div class="line">        m_viewDir(rc.rayparams.viewDir),</div>
<div class="line">        m_dDdx(rc.rayparams.dDdx),</div>
<div class="line">        m_dDdy(rc.rayparams.dDdx),</div>
<div class="line">        m_dPdx(rc.rayresult.dPdx),</div>
<div class="line">        m_dPdy(rc.rayresult.dPdx),</div>
<div class="line">        m_localRayType(rc.rayparams.localRayType),</div>
<div class="line">        m_pathLength(rc.rayresult.pathLength),</div>
<div class="line">        m_validElements(rc.lightingResult.validElements)</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~AutoSaveRayContextData() { restoreContext(); }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> restoreContext() {</div>
<div class="line">        m_rc.rayresult.wpointCoeff = m_wpointCoeff;</div>
<div class="line">        m_rc.rayparams.tracedRay.dir = m_rayTracedDir;</div>
<div class="line">        m_rc.rayparams.viewDir = m_viewDir;</div>
<div class="line">        m_rc.rayparams.dDdx = m_dDdx;</div>
<div class="line">        m_rc.rayparams.dDdy = m_dDdy;</div>
<div class="line">        m_rc.rayresult.dPdx = m_dPdx;</div>
<div class="line">        m_rc.rayresult.dPdy = m_dPdy;</div>
<div class="line">        m_rc.rayparams.localRayType = m_localRayType;</div>
<div class="line">        m_rc.rayresult.pathLength = m_pathLength;</div>
<div class="line">        m_rc.lightingResult.validElements = m_validElements;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VR::VRayContext &amp;m_rc;</div>
<div class="line">    <span class="keyword">const</span> VR::Ireal m_wpointCoeff;</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeVec m_viewDir;</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeVec m_rayTracedDir;</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeVec m_dDdx;</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeVec m_dDdy;</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeVec m_dPdx;</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeVec m_dPdy;</div>
<div class="line">    <span class="keyword">const</span> VR::RayFlags m_localRayType;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> m_pathLength;</div>
<div class="line">    <span class="keyword">const</span> uint64_t m_validElements;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_noz_point.html">NozVector</a> getVrayWSVelocity(<span class="keyword">const</span> VR::VRayContext &amp;rc) {</div>
<div class="line"> </div>
<div class="line">    VR::ObjectShadeInstance *si = (VR::ObjectShadeInstance*) GET_INTERFACE(rc.rayresult.si, EXT_OBJECT_SHADE_INSTANCE);</div>
<div class="line">    VR::ShadeVec vel = si ? si-&gt;getVelocity(rc) : VR::ShadeVec(0.0f, 0.0f, 0.0f);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group___n_o_z__vector.html#ga347d85f3e636cf273a47949aa0613a8f">NozVector</a>(vel.x(), vel.y(), vel.z());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">PresenZIntersectionShader::PresenZIntersectionShader(PresenZSettings *pSettings) : presenZSettings(pSettings) {}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_noz_point.html">NozVector</a> GetPlaneIntersect(<span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; planePoint, <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; planeNormal, <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; linePoint, <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; lineDir)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> denom = <a class="code" href="group___n_o_z__vector.html#ga28a60e393933a7a2d9ea26106d74b8e1">NozVecDot</a>(planeNormal, lineDir);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (fabs(denom) &gt; FLT_EPSILON) {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> p0l0x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(planePoint.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>) - <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(linePoint.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> p0l0y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(planePoint.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>) - <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(linePoint.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> p0l0z = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(planePoint.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>) - <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(linePoint.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> num = p0l0x * planeNormal.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a> + p0l0y * planeNormal.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a> + p0l0z * planeNormal.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> t = num / denom;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> linePoint + t * lineDir;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> planePoint;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> GetLeftEyeViewDir(VRayContext &amp;rc, <a class="code" href="struct_noz_point.html">NozVector</a> &amp;leftEyeDir) {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> Gn = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayresult.gnormal.x(), rc.rayresult.gnormal.y(), rc.rayresult.gnormal.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> Nn = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayresult.normal.x(), rc.rayresult.normal.y(), rc.rayresult.normal.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> camDir = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayparams.viewDir.x(), rc.rayparams.viewDir.y(), rc.rayparams.viewDir.z());</div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozPoint</a> worldHitPoint(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozPoint</a> bestCamWS = <a class="code" href="group___pz_shading_api.html#ga7b1e9d6ef33e499eca978c3dba837d98">PresenZ::Shading::PzGetBestCameraWSPosition</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()));</div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html">PresenZ::Shading::PzBendRay</a> newCamRay = <a class="code" href="group___pz_shading_api.html#gab494b6706b2ce7119c4736a70bd6f594">PresenZ::Shading::PzGetBendRayRenderPhase</a>(<a class="code" href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fa4280d82f18d6dbafdeb68c811112455e">PresenZ::Phase::Eye::RC_Left</a>,Gn, Gn, camDir, worldHitPoint, hitDistance, bestCamWS);</div>
<div class="line">    leftEyeDir = newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bend the camera to simulate it has been seen by the right/left eye. Invoked before shading so you</span></div>
<div class="line"><span class="comment">// get the right shade for the right eye in the VR mask.</span></div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::bendCameraRay(VRayContext &amp;rc, <span class="keywordtype">bool</span> rightEye)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Normal shading, override the smooth surface normal for specular bending. V-Ray does not allow the</span></div>
<div class="line">    <span class="comment">// overriding of the camera position and camera ray length. You could modify rc.rayparams.tracedRay instead,</span></div>
<div class="line">    <span class="comment">// if it is needed.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> Nn = <a class="code" href="group___n_o_z__vector.html#ga19bf5d776ee066f688d5432fe9ce257f">NozVecNormalize</a>( <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayresult.normal.x(), rc.rayresult.normal.y(), rc.rayresult.normal.z()) );</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> Gn = <a class="code" href="group___n_o_z__vector.html#ga19bf5d776ee066f688d5432fe9ce257f">NozVecNormalize</a>(<a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayresult.gnormal.x(), rc.rayresult.gnormal.y(), rc.rayresult.gnormal.z()));</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> camDir = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayparams.viewDir.x(), rc.rayparams.viewDir.y(), rc.rayparams.viewDir.z());</div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozPoint</a> worldHitPoint( ptWorld.x(), ptWorld.y(), ptWorld.z() );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line">    <a class="code" href="group___pz_phase_api.html#ga3104904c134a52357b85f763f6dfd48f">PresenZ::Phase::Eye</a> eye = rightEye ? <a class="code" href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fac2b22af1f16cebd2cc909767c763a713">PresenZ::Phase::Eye::RC_Right</a> : <a class="code" href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fa4280d82f18d6dbafdeb68c811112455e">PresenZ::Phase::Eye::RC_Left</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozPoint</a> bestCamWS = <a class="code" href="group___pz_shading_api.html#ga7b1e9d6ef33e499eca978c3dba837d98">PresenZ::Shading::PzGetBestCameraWSPosition</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()));</div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> bestCamWsDir = <a class="code" href="group___n_o_z__vector.html#ga19bf5d776ee066f688d5432fe9ce257f">NozVecNormalize</a>(worldHitPoint - bestCamWS);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html">PresenZ::Shading::PzBendRay</a> newCamRay = <a class="code" href="group___pz_shading_api.html#gab494b6706b2ce7119c4736a70bd6f594">PresenZ::Shading::PzGetBendRayRenderPhase</a>(eye, Gn, Nn, camDir, worldHitPoint, hitDistance, bestCamWS);</div>
<div class="line"> </div>
<div class="line">    rc.rayparams.viewDir = VR::ShadeVec(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line">    rc.rayparams.tracedRay.dir = VR::ShadeVec(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line">    rc.rayresult.wpointCoeff = newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#ab44f0a3b38724b93889067c8dc6e9469">wHitDistance</a>;</div>
<div class="line">    <span class="comment">// LightCache GI needs PathLength as well. otherwise it makes stains, because it doen&#39;t evaluate properly.. </span></div>
<div class="line">    rc.rayresult.pathLength = newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#ab44f0a3b38724b93889067c8dc6e9469">wHitDistance</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2. / (presenZSettings-&gt;imageResolutionX );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2. / (presenZSettings-&gt;imageResolutionY );</div>
<div class="line"> </div>
<div class="line">    newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a> *= dx;</div>
<div class="line">    newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a> *= dy;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> dPdx = GetPlaneIntersect(worldHitPoint, Gn, bestCamWS, bestCamWsDir + newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>) - worldHitPoint;</div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> dPdy = GetPlaneIntersect(worldHitPoint, Gn, bestCamWS, bestCamWsDir + newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>) - worldHitPoint;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// re-inject world space derivative</span></div>
<div class="line">    rc.rayparams.dDdx.setx(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">    rc.rayparams.dDdx.sety(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">    rc.rayparams.dDdx.setz(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line">    rc.rayparams.dDdy.setx(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">    rc.rayparams.dDdy.sety(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">    rc.rayparams.dDdy.setz(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line"> </div>
<div class="line">    rc.rayresult.dPdx.setx(dPdx.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">    rc.rayresult.dPdx.sety(dPdx.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">    rc.rayresult.dPdx.setz(dPdx.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line">    rc.rayresult.dPdy.setx(dPdy.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">    rc.rayresult.dPdy.sety(dPdy.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">    rc.rayresult.dPdy.setz(dPdy.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//rc.rayparams.dDdx *= dx;</span></div>
<div class="line">   <span class="comment">// rc.rayparams.dDdy *= dy;</span></div>
<div class="line"><span class="comment"></span>    <span class="comment">//VR::getBumpDerivs(rc, rc.rayresult.gnormal.getUnitVector(), rc.rayresult.dPdx, rc.rayresult.dPdy);</span></div>
<div class="line">   </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a25d24f3fc254ac9d7f43b9be22fadd34">isStereoScopic</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::traceCamRayForShadingTransparentSurface(VRayContext &amp;rc, <span class="keywordtype">bool</span> rightEye) {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> Nn = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayresult.normal.x(), rc.rayresult.normal.y(), rc.rayresult.normal.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> camDir = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(rc.rayparams.viewDir.x(), rc.rayparams.viewDir.y(), rc.rayparams.viewDir.z());</div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozPoint</a> worldHitPoint(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line">    <a class="code" href="group___pz_phase_api.html#ga3104904c134a52357b85f763f6dfd48f">PresenZ::Phase::Eye</a> eye = rightEye ? <a class="code" href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fac2b22af1f16cebd2cc909767c763a713">PresenZ::Phase::Eye::RC_Right</a> : <a class="code" href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fa4280d82f18d6dbafdeb68c811112455e">PresenZ::Phase::Eye::RC_Left</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html">PresenZ::Shading::PzBendRayEx</a> newCamRay = <a class="code" href="group___pz_shading_api.html#ga6478fef8d991dafb6f7568600f57cf9c">PresenZ::Shading::PzGetTranspRayRenderPhase</a>(eye, Nn, camDir, worldHitPoint, hitDistance);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec dir(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">dir</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>); <span class="comment">//direction</span></div>
<div class="line">    <span class="keyword">const</span> ShadeVec Ori(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a3e1a826396726caf4930542970259fef">origin</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a3e1a826396726caf4930542970259fef">origin</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a3e1a826396726caf4930542970259fef">origin</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>); <span class="comment">// rayOrigin</span></div>
<div class="line">    VRayContext &amp;nrc = rc.newSpawnContext(0, ShadeCol(1.0f, 1.0f, 1.0f), VR::RayFlags(RT_CAMERA), dir);  <span class="comment">// newShading context to trace a new ray.</span></div>
<div class="line">    nrc.setTracedRay(TraceRay(Ori, dir), newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#ab44f0a3b38724b93889067c8dc6e9469">wHitDistance</a>, LARGE_FLOAT, <span class="keyword">true</span>, rc.rayresult.skipTag); <span class="comment">// setup the vray ray</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2. / (presenZSettings-&gt;imageResolutionX);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2. / (presenZSettings-&gt;imageResolutionY);</div>
<div class="line">    </div>
<div class="line">    nrc.rayparams.dDdx.setx(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">    nrc.rayparams.dDdx.sety(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">    nrc.rayparams.dDdx.setz(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">dDdx</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line">    nrc.rayparams.dDdy.setx(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>);</div>
<div class="line">    nrc.rayparams.dDdy.sety(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>);</div>
<div class="line">    nrc.rayparams.dDdy.setz(newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">dDdy</a>.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line">    nrc.rayparams.dDdx *= dx;</div>
<div class="line">    nrc.rayparams.dDdy *= dy;</div>
<div class="line">    VR::getBumpDerivs(rc, rc.rayresult.gnormal.getUnitVector(), rc.rayresult.dPdx, rc.rayresult.dPdy);</div>
<div class="line"> </div>
<div class="line">    nrc.traceRay(TraceRay(Ori, dir), newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#ab44f0a3b38724b93889067c8dc6e9469">wHitDistance</a>, LARGE_FLOAT); <span class="comment">// traceRay</span></div>
<div class="line">    rc.mtlresult.add(nrc.shaderesult);  <span class="comment">// composite result to the current shade.</span></div>
<div class="line">    nrc.releaseContext();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> newCamRay.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">pzBendRay</a>.<a class="code" href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a25d24f3fc254ac9d7f43b9be22fadd34">isStereoScopic</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This method is invoked just before rendering so the intersection shader can take appropriate action</span></div>
<div class="line"><span class="comment">// depending which phase PresenZ is in.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::setupShadingMethods() {</div>
<div class="line"> </div>
<div class="line">    prz_shading = &amp;PresenZIntersectionShader::shadeEvalOpaque;</div>
<div class="line"> </div>
<div class="line">    m_invisibleForCameraRay.clear();</div>
<div class="line">    m_invisibleForProbeRay.clear();</div>
<div class="line">    m_shadeable.clear();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">//PZ_WARNING_TEST_ONLYONCE(presenZSettings-&gt;glassMode != PresenZ::Phase::PRZ_BOTH, &quot;[PresenZ] Simultaneous rendering of both opaque and transparent at the same time is not fully supported yet.&quot;);</span></div>
<div class="line">    <span class="comment">// to be tested on the chaosGroup glass test scene and the PresenZ glass Material</span></div>
<div class="line">   </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a>) {</div>
<div class="line">        prz_shading = &amp;PresenZIntersectionShader::shadeEvalRenderReflection;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;glassMode == (<span class="keywordtype">int</span>)<a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da7dd4b95e541632ef996ef1aeaf346dcc">PresenZ::Phase::PRZ_REGULAR</a>) {</div>
<div class="line">        prz_shading = &amp;PresenZIntersectionShader::shadeEvalOpaque;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;glassMode == <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da9d90fb508b0f83e7938ec40d18de14a9">PresenZ::Phase::PRZ_OPAQUE</a>) {</div>
<div class="line">        prz_shading = &amp;PresenZIntersectionShader::shadeEvalOpaque;</div>
<div class="line"> </div>
<div class="line">        m_invisibleForCameraRay.push_back(&amp;PresenZIntersectionShader::isPrzGlassSurface);</div>
<div class="line">        m_invisibleForCameraRay.push_back(&amp;PresenZIntersectionShader::isPrzTranspSurface);</div>
<div class="line">        m_invisibleForCameraRay.push_back(&amp;PresenZIntersectionShader::isPrzBrdfGlassSurface);</div>
<div class="line"> </div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzGlassSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzTranspSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzBrdfGlassSurface);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;glassMode == <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da207fada585bc6f4ef37fcc78adff9960">PresenZ::Phase::PRZ_TRANSP</a>) {</div>
<div class="line">        prz_shading = &amp;PresenZIntersectionShader::shadeEvalTransparent;</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzGlassSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzTranspSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzBrdfGlassSurface);</div>
<div class="line"> </div>
<div class="line">        m_shadeable.push_back(&amp;PresenZIntersectionShader::isPrzGlassSurface); <span class="comment">// stops eye ray on nonPrzIOR surfaces</span></div>
<div class="line">        m_shadeable.push_back(&amp;PresenZIntersectionShader::isPrzTranspSurface); <span class="comment">// stops eye ray on nonPrzTransp surfaces</span></div>
<div class="line">        m_shadeable.push_back(&amp;PresenZIntersectionShader::isPrzBrdfGlassSurface); <span class="comment">// stops eye ray on nonPrzTransp surfaces</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;glassMode == <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4daf1fb663f950f6e485ca1a18bf9d3f2ee">PresenZ::Phase::PRZ_BOTH</a>)</div>
<div class="line">    {</div>
<div class="line">        prz_shading = &amp;PresenZIntersectionShader::shadeEvalOpaqueAndTransparent;</div>
<div class="line"> </div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzGlassSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzTranspSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isPrzBrdfGlassSurface);</div>
<div class="line"> </div>
<div class="line">        m_shadeable.push_back(&amp;PresenZIntersectionShader::isPrzGlassSurface); <span class="comment">// stops eye ray on nonPrzIOR surfaces</span></div>
<div class="line">        m_shadeable.push_back(&amp;PresenZIntersectionShader::isPrzTranspSurface); <span class="comment">// stops eye ray on nonPrzTransp surfaces</span></div>
<div class="line">        m_shadeable.push_back(&amp;PresenZIntersectionShader::isPrzBrdfGlassSurface); <span class="comment">// stops eye ray on nonPrzTransp surfaces</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// nothing is invisible to probe for this phase !</span></div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::Detect_Reflection</a>)</div>
<div class="line">        m_invisibleForProbeRay.clear();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;makeInvisibleLight == 1) {</div>
<div class="line">        m_invisibleForCameraRay.push_back(&amp;PresenZIntersectionShader::isLightSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isLightSurface);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;makeInvisibleLight &gt;= 2) {</div>
<div class="line">        m_invisibleForCameraRay.push_back(&amp;PresenZIntersectionShader::isTransparentLightSurface);</div>
<div class="line">        m_invisibleForProbeRay.push_back(&amp;PresenZIntersectionShader::isTransparentLightSurface);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ( presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a48a95ceab76284afa466622424eba555">PresenZ::Phase::Detect</a> || presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::Detect_Reflection</a> ) { <span class="comment">// detectHole mode</span></div>
<div class="line">        prz_shading = &amp;PresenZIntersectionShader::shadeDetectPhase;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shade_RENDERREFLECTIONRAY(VRayContext &amp;rc) {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    bendCameraRay(rc, <span class="keyword">false</span>);</div>
<div class="line">    presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line">    rc.mtlresult.makeOpaque(rc.mtlresult.color);</div>
<div class="line">    Color mapVrayColor = rc.vray-&gt;getSequenceDataPtr()-&gt;colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorL = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line">    <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorR = colorL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> prz_IOR_value = 1.0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isGlassSurface = checkUserAttribute(rc, rc.rayresult, VT_glassIOR, prz_IOR_value);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isMirror = (prz_IOR_value &gt;= 2.0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line">    outputRenderSample(rc, colorL, colorR, rc.mtlresult.alpha.intensity(), isGlassSurface, isMirror);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeEvalRenderReflection(VR::VRayContext &amp;rc) {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isChaotic = isPrzChaoticSurface(rc, rc.rayresult);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!(isPrzGlassSurface(rc, rc.rayresult, rc) || isPrzTranspSurface(rc, rc.rayresult, rc) || isChaotic))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(isChaotic)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group___pz_shading_api.html#ga92c23c7b028873c784d8fd74bef4292f">PresenZ::Shading::PzIsValidEvaluation</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()), hitDistance, isChaotic) == <span class="keyword">false</span>)</div>
<div class="line">        {</div>
<div class="line">            outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 0);</div>
<div class="line">            rc.mtlresult.makeOpaque(Color(0., 0., 0.));</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        shadeEvalOpaque(rc);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> goThrough = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    ShadeVec offset(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitPoint = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitNormal(rc.rayresult.gnormal.getUnitVector().x(), rc.rayresult.gnormal.getUnitVector().y(), rc.rayresult.gnormal.getUnitVector().z());</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> shadeCurrentPoint = <a class="code" href="group___pz_shading_api.html#gae26a93bf43d6cb1f25a79823ab2fe2eb">PresenZ::Shading::PzShouldShade</a>(hitPoint, hitNormal, rc.rayparams.getScreenX(), rc.rayparams.getScreenY(), goThrough);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!shadeCurrentPoint) {</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough)</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> incomingRayDir(rc.rayparams.viewDir.getUnitVector().x(), rc.rayparams.viewDir.getUnitVector().y(), rc.rayparams.viewDir.getUnitVector().z());</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> reflectDir = <a class="code" href="group___pz_shading_api.html#ga37c6f602200a7c66975426ba37d7ed5f">PresenZ::Shading::PzGetReflectionDirection</a>(incomingRayDir, rc.rayparams.getScreenX(), rc.rayparams.getScreenY());</div>
<div class="line">        </div>
<div class="line">        VR::Float3 reflectDirVr(reflectDir.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, reflectDir.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, reflectDir.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//VR::getReflectDir(rc.rayparams.viewDir, rc.rayresult.gnormal);</span></div>
<div class="line">        VR::Float3 reflect_dDdx, reflect_dDdy;</div>
<div class="line">        VR::getReflectDerivs(rc.rayparams.viewDir, reflectDirVr, rc.rayparams.dDdx, rc.rayparams.dDdy, reflect_dDdx, reflect_dDdy);</div>
<div class="line"> </div>
<div class="line">        TraceRay  reflectRay(rc.rayresult.wpoint, reflectDirVr);</div>
<div class="line">        VRayContext &amp;nrc = rc.newSpawnContext(0, ShadeCol(1.0f, 1.0f, 1.0f), VR::RayFlags(RT_CAMERA | RENDERREFLECTIONRAY), reflectDirVr);  <span class="comment">// newShading context to trace a new ray.</span></div>
<div class="line">        nrc.setTracedRay(reflectRay, 0.0001, LARGE_FLOAT, <span class="keyword">true</span>, rc.rayresult.skipTag); <span class="comment">// setup the vray ray</span></div>
<div class="line">        nrc.rayparams.dDdx = reflect_dDdx;</div>
<div class="line">        nrc.rayparams.dDdy = reflect_dDdy;</div>
<div class="line">        nrc.traceRay(reflectRay, 0.0001, LARGE_FLOAT); <span class="comment">// traceRay</span></div>
<div class="line"> </div>
<div class="line">        rc.mtlresult.makeOpaque(nrc.mtlresult.color);</div>
<div class="line">        nrc.releaseContext();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (goThrough) {</div>
<div class="line">            rc.mtlresult.transp.makeWhite();</div>
<div class="line">            rc.mtlresult.alpha.makeZero();</div>
<div class="line">            rc.mtlresult.alphaTransp.makeWhite();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            rc.mtlresult.transp.makeZero();</div>
<div class="line">            rc.mtlresult.alpha.makeWhite();</div>
<div class="line">            rc.mtlresult.alphaTransp.makeZero();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isShadeTransp(<span class="keyword">const</span> VRayContext &amp;rc, <span class="keyword">const</span> ShadeVec &amp;pt, <span class="keyword">const</span> ShadeVec &amp;dir, <span class="keywordtype">double</span> maxDist, <span class="keywordtype">float</span> rx, <span class="keywordtype">float</span> ry, <span class="keywordtype">float</span> &amp;transp)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> value = 0.f;</div>
<div class="line">    <span class="keywordflow">if</span> (!isPrzStencilSurface(rc, rc.rayresult)) {</div>
<div class="line">        transp = 0;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> imAlight = <span class="keyword">false</span>;</div>
<div class="line">    BSDFInterface *bsdfInterface = queryInterface&lt;BSDFInterface&gt;(rc.rayresult.sb, EXT_BSDF);</div>
<div class="line">    <span class="keywordflow">if</span> (!bsdfInterface) </div>
<div class="line">        imAlight = queryInterface&lt;LightInterface&gt;(rc.rayresult.sb, EXT_LIGHT) != <span class="keyword">nullptr</span>;</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (imAlight) {</div>
<div class="line">        transp = 0.0;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptOri = pt;<span class="comment">// +ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</span></div>
<div class="line">    TraceRay  probeRay(ptOri, dir.getUnitVector());</div>
<div class="line">    VRayContext &amp;nrc = rc.newSpawnContext(1, ShadeCol(1.0f, 1.0f, 1.0f), VR::RayFlags(RT_CAMERA | RT_SHADETRANSPONLY | PROBESHADE), dir.getUnitVector());  <span class="comment">// newShading context to trace a new ray.</span></div>
<div class="line">    nrc.clear();</div>
<div class="line">    nrc.rayparams.rayOrigin = ptOri;</div>
<div class="line">    nrc.rayparams.viewDir = dir.getUnitVector();</div>
<div class="line">    nrc.rayparams.tracedRay = probeRay;</div>
<div class="line">    <span class="comment">//nrc.rayparams.rayType = VR::RayFlags(RT_CAMERA | RT_SHADETRANSPONLY | PROBESHADE);</span></div>
<div class="line">    nrc.rayparams.rayType = VR::RayFlags(RT_SHADOW | RT_NOGI | RT_SHADETRANSPONLY | RT_NOSPECULAR | PROBESHADE);<span class="comment">// (RT_SHADETRANSPONLY | RT_SKIP_SHADOW_RAYS | PROBESHADE);</span></div>
<div class="line">    nrc.rayparams.localRayType = VR::RayFlags(RT_SHADOW | RT_NOGI | RT_SHADETRANSPONLY | RT_NOSPECULAR | PROBESHADE);</div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> dDdx;</div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> dDdy;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    PresenZ::Shading::getBendRayDerivative_cameraSpace(NozVector(dir.x(), dir.y(), dir.z()), dDdx, dDdy);</span></div>
<div class="line"><span class="comment">    //const float dx = 2. / (288.);</span></div>
<div class="line"><span class="comment">    //const float dy = 2. / (192.);</span></div>
<div class="line"><span class="comment">    const float dx = 2. / rx;</span></div>
<div class="line"><span class="comment">    const float dy = 2. / ry;</span></div>
<div class="line"><span class="comment">    // re-inject world space derivative</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    nrc.setTracedRay(probeRay, 0.0001, LARGE_FLOAT, false, nullptr); // setup the vray ray</span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdx.setx(dDdx.x);</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdx.sety(dDdx.y);</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdx.setz(dDdx.z);</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdy.setx(dDdy.x);</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdy.sety(dDdy.y);</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdy.setz(dDdy.z);</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdx *= dx;</span></div>
<div class="line"><span class="comment">    nrc.rayparams.dDdy *= dy;</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    nrc.rayresult.wpointCoeff = dir.length();</div>
<div class="line">    <span class="comment">// LightCache GI needs PathLength as well. otherwise it makes stains, because it doen&#39;t evaluate properly.. </span></div>
<div class="line">    nrc.rayresult.pathLength = dir.length();</div>
<div class="line">    <span class="comment">//VR::getBumpDerivs(nrc, nrc.rayresult.gnormal.getUnitVector(), nrc.rayresult.dPdx, nrc.rayresult.dPdy);</span></div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    nrc.traceRay(probeRay, 0.01, LARGE_FLOAT); <span class="comment">// traceRay with an offset from the preious surface to avoid acne effect... Didn&#39;t find any way to get the skipTag from the previous surface. </span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//nrc.rayparams.dDdx = reflect_dDdx;</span></div>
<div class="line">    <span class="comment">//nrc.rayparams.dDdy = reflect_dDdy;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> tr = !nrc.mtlresult.transp.isBlack();</div>
<div class="line"> </div>
<div class="line">    transp = nrc.mtlresult.transp.intensity();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    //std::string na = nrc.rayresult.sb-&gt;getName(nrc);</span></div>
<div class="line"><span class="comment">    const ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</span></div>
<div class="line"><span class="comment">    const NozPoint hitPointWorld(ptWorld.x(), ptWorld.y(), ptWorld.z());</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    ShadeVec offset(rc.vray-&gt;getFrameData().sceneOffset);</span></div>
<div class="line"><span class="comment">    if (tr) {</span></div>
<div class="line"><span class="comment">        int pp = 0;</span></div>
<div class="line"><span class="comment">        std::string trs = &quot;curve -d 1 -p &quot; + std::to_string(hitPointWorld.x) + &quot; &quot; + std::to_string(hitPointWorld.y) + &quot; &quot; + std::to_string(hitPointWorld.z) + &quot; &quot;;</span></div>
<div class="line"><span class="comment">        std::string trs0 = &quot; -p &quot; + std::to_string(ptOri.x()) + &quot; &quot; + std::to_string(ptOri.y()) + &quot; &quot; + std::to_string(ptOri.z()) + &quot;  -k 0 -k 1 ;\n&quot;;</span></div>
<div class="line"><span class="comment">        //OutputDebugStringA((trs + trs0).c_str());</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    else {</span></div>
<div class="line"><span class="comment">        // curve -d 1 -p -165.410688 0 1.57843 -p -261.505508 0 63.759041 -k 0 -k 1 ;</span></div>
<div class="line"><span class="comment">        int cc = 0;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        std::string trs = &quot; curve -d 1 -p &quot; + std::to_string(hitPointWorld.x) + &quot; &quot; + std::to_string(hitPointWorld.y) + &quot; &quot; + std::to_string(hitPointWorld.z) + &quot; &quot;;</span></div>
<div class="line"><span class="comment">        std::string trs0 = &quot; -p &quot; + std::to_string(ptOri.x()) + &quot; &quot; + std::to_string(ptOri.y()) + &quot; &quot; + std::to_string(ptOri.z()) + &quot;  -k 0 -k 1 ;\n&quot;;</span></div>
<div class="line"><span class="comment">        //OutputDebugStringA((trs + trs0).c_str());</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    nrc.releaseContext();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tr;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Main callback from Vray. All information regarding hit impact is contained in VrayContext. </span></div>
<div class="line"><span class="comment">// Note: If the mtlresult is made transparent (makeTransparent) the ray will go through and continue its course.</span></div>
<div class="line"><span class="keywordtype">int</span> PresenZIntersectionShader::shade2(VRayContext &amp;rc) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!presenZSettings-&gt;lightCacheDone) {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// VRAY FREEZE HACK</span></div>
<div class="line">        <span class="keywordflow">if</span> (presenZSettings-&gt;makeInvisibleLight == 4 &amp;&amp; (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a48a95ceab76284afa466622424eba555">PresenZ::Phase::Detect</a> || presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::Detect_Reflection</a> ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rc.rayparams.rayType &amp; RT_CAMERA &amp;&amp; checkIfSurfaceIs(m_invisibleForCameraRay, rc, rc.rayresult, rc)){</div>
<div class="line">            rc.mtlresult.makeTransparent();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rc.rayparams.rayType &amp; PROBESHADE) {</div>
<div class="line"> </div>
<div class="line">        presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ( presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a></div>
<div class="line">        &amp;&amp; rc.rayparams.rayType &amp; RENDERREFLECTIONRAY ) {</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (checkIfSurfaceIs(m_invisibleForCameraRay, rc, rc.rayresult, rc)) {</div>
<div class="line">            rc.mtlresult.makeTransparent();</div>
<div class="line">            rc.mtlresult.transp.makeWhite();</div>
<div class="line">            rc.mtlresult.alpha.makeZero();</div>
<div class="line">            rc.mtlresult.alphaTransp.makeWhite();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        rc.rayparams.rayType &amp;= ~RENDERREFLECTIONRAY;</div>
<div class="line">        shade_RENDERREFLECTIONRAY(rc);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> isShadowRay = (rc.rayparams.rayType &amp; RT_SHADOW) != 0; <span class="comment">// This is a shadow ray</span></div>
<div class="line">    <span class="keywordtype">int</span> isPrimaryCameraRay = ((rc.rayparams.rayType &amp; RT_CAMERA) != 0 &amp;&amp; (rc.rayparams.totalLevel == 0)); <span class="comment">// Ray is a primary camera ray</span></div>
<div class="line">    <span class="keywordtype">int</span> isReflectionRay = (rc.rayparams.rayType &amp; RT_REFLECT) != 0; <span class="comment">// Ray has gone through at least one reflection</span></div>
<div class="line">    <span class="keywordtype">int</span> isRefractionRay = (rc.rayparams.rayType &amp; RT_REFRACT) != 0; <span class="comment">// Ray has gone through at least one refraction</span></div>
<div class="line">    <span class="keywordtype">int</span> isGlossyRay = (rc.rayparams.rayType &amp; RT_GLOSSY) != 0; <span class="comment">// Ray has gone through at least one glossy interaction (reflection or refraction)</span></div>
<div class="line">    <span class="keywordtype">int</span> isGIRay = ( (rc.rayparams.rayType &amp; RT_INDIRECT) != 0 || rc.rayparams.currentPass == RPASS_GI) ; <span class="comment">// Ray has gone through at least one diffuse GI reflection</span></div>
<div class="line">    <span class="keywordtype">int</span> camray = (rc.rayparams.rayType &amp; RT_CAMERA);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!isPrimaryCameraRay || isShadowRay || isReflectionRay || isGlossyRay || isGIRay || isRefractionRay || rc.rayresult.getSurfaceHit() == 0) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (checkIfSurfaceIs(m_invisibleForCameraRay, rc, rc.rayresult, rc)) {</div>
<div class="line">        rc.mtlresult.makeTransparent();</div>
<div class="line">        rc.mtlresult.transp.makeWhite();</div>
<div class="line">        rc.mtlresult.alpha.makeZero();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeWhite();</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">float</span> value = 0.0;</div>
<div class="line">        <span class="comment">// check for mate objects, don&#39;t render them.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> isMatte = rc.rayresult.surfaceProps ? rc.rayresult.surfaceProps-&gt;matte : false ;</div>
<div class="line">        <span class="comment">// check for non-isolated object. don&#39;t render them</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> notisolated = (presenZSettings-&gt;renderIsolated == 1) &amp;&amp; (!isPrzIsolatedSurface(rc, rc.rayresult));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (isMatte || notisolated ) {</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (isPrzGlassSurface(rc, rc.rayresult, rc) || isPrzTranspSurface(rc, rc.rayresult, rc) || isPrzBrdfGlassSurface(rc, rc.rayresult, rc)) {</div>
<div class="line">                rc.mtlresult.makeTransparent();</div>
<div class="line">                rc.mtlresult.transp.makeWhite();</div>
<div class="line">                rc.mtlresult.alpha.makeZero();</div>
<div class="line">                rc.mtlresult.alphaTransp.makeWhite();</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                rc.mtlresult.makeOpaque();</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> ( isMatte &amp;&amp; ( presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84ac677a954de25220db675695edacb4f71">PresenZ::Phase::Render</a></div>
<div class="line">               || presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a> )</div>
<div class="line">                ) {</div>
<div class="line">                    outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0, 0);</div>
<div class="line">                }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="group___pz_detect_sample_api.html#ga4235bda2ada163773d83c4d1d6c75bc0">PresenZ::DetectSample::DetectSample_transp</a> qtransp = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> check = <a class="code" href="group___pz_shading_api.html#ga7835dda2492d50eb922bac277a1b731a">PresenZ::Shading::PzIsTransparent</a>(rc.rayparams.getScreenX(), rc.rayparams.getScreenY(), qtransp);</div>
<div class="line">    <span class="keywordflow">if</span> (qtransp == <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53">PresenZ::DetectSample::DST_glass</a> &amp;&amp; m_shadeable.size()  ) {</div>
<div class="line">        <span class="keywordtype">bool</span> shade = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (PresenZIntersectionShader::checkSurfaceFuncArray::iterator fctPtrIt = m_shadeable.begin(); fctPtrIt != m_shadeable.end(); fctPtrIt++) {</div>
<div class="line">            <span class="keywordtype">bool</span> res = (this-&gt;*(*fctPtrIt))(rc, rc.rayresult, rc);</div>
<div class="line">            <span class="keywordflow">if</span> (res) {</div>
<div class="line">                shade = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (!shade) {</div>
<div class="line">            <span class="comment">// we don&#39;t want to shade the sample on this surface. It&#39;s not a glass.</span></div>
<div class="line">            rc.mtlresult.makeOpaque();</div>
<div class="line">            <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84ac677a954de25220db675695edacb4f71">PresenZ::Phase::Render</a> || presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a>)</div>
<div class="line">                outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 1.0, 0);   <span class="comment">// not a glass &lt;- opaque &lt;- 0</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    (this-&gt;*prz_shading)(rc); </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> checkTagByVraySSSID(<span class="keyword">const</span> VR::VRayContext &amp;rc, FP_SSSID_bit BIT) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// querying the name of a forest pack object led to a crash . . .</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!rc.rayresult.getSurfaceProperties())</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> sssId = rc.rayresult.getSurfaceProperties()-&gt;getSSSID() - 1014;</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (sssId &lt; 0 || sssId &gt;= 256 )</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">char</span> sssIdtags = sssId;</div>
<div class="line">    <span class="keywordflow">return</span> sssIdtags &amp; (1 &lt;&lt; BIT);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeEvalStencil(VR::VRayContext &amp;rc, <a class="code" href="group___pz_detect_sample_api.html#ga4235bda2ada163773d83c4d1d6c75bc0">PresenZ::DetectSample::DetectSample_transp</a> qtransp) {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isChaotic = isPrzChaoticSurface(rc, rc.rayresult);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___pz_shading_api.html#ga92c23c7b028873c784d8fd74bef4292f">PresenZ::Shading::PzIsValidEvaluation</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()), hitDistance, isChaotic) == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 0);</div>
<div class="line">        rc.mtlresult.makeOpaque(Color(0., 0., 0.));</div>
<div class="line">  </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitPoint = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitNormal(rc.rayresult.gnormal.getUnitVector().x(), rc.rayresult.gnormal.getUnitVector().y(), rc.rayresult.gnormal.getUnitVector().z());</div>
<div class="line">    ShadeVec offset(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> goThrough = <span class="keyword">false</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> ( !isChaotic ){</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> shadeCurrentPoint = <a class="code" href="group___pz_shading_api.html#gae26a93bf43d6cb1f25a79823ab2fe2eb">PresenZ::Shading::PzShouldShade</a>(hitPoint, hitNormal, rc.rayparams.getScreenX(), rc.rayparams.getScreenY(), goThrough);</div>
<div class="line">        <span class="keywordflow">if</span> (!shadeCurrentPoint) {</div>
<div class="line">            <span class="keywordflow">if</span> (goThrough) { </div>
<div class="line"> </div>
<div class="line">                rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line"> </div>
<div class="line">                rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    AutoSaveRayContextData savedVrayContextData(rc);</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeResult savedMtlresult = rc.mtlresult;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> leftOrRight = presenZSettings-&gt;deepReflection == 2; <span class="comment">// if true, we bend for the right eye. </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isStereoScopicPointOfView = bendCameraRay(rc, leftOrRight) &amp;&amp; isPrzStereoRightEye(rc, rc.rayresult);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if we&#39;re shading just the right eye only but this is not a stereoscopic pov, we output black for the moment...</span></div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 2 &amp;&amp; !isStereoScopicPointOfView) {</div>
<div class="line">        outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 0);</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough) {</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rc.mtlresult.alpha.intensity() &lt;= 0.0 &amp;&amp; rc.mtlresult.transp.intensity() &gt;= 1.0) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ShadeCol originalShade = rc.mtlresult.color;</div>
<div class="line">    Color mapVrayColor = rc.vray-&gt;getSequenceDataPtr()-&gt;colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorL = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line">    <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorR = colorL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 1 &amp;&amp; isStereoScopicPointOfView) {</div>
<div class="line"> </div>
<div class="line">        savedVrayContextData.restoreContext();</div>
<div class="line">        rc.mtlresult = savedMtlresult;</div>
<div class="line"> </div>
<div class="line">        bendCameraRay(rc, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">        presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line"> </div>
<div class="line">        mapVrayColor = rc.vray-&gt;getSequenceData().colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line">        colorR = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line"> </div>
<div class="line">        rc.mtlresult.color += originalShade; <span class="comment">// adds the left eye shade to the right eye shade in order two take into account the two shades for the vray adaptation.</span></div>
<div class="line">        rc.mtlresult.color /= 2.0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Restore the rc context you change for bending and evaluating before releasing it    </span></div>
<div class="line">    savedVrayContextData.restoreContext();</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> a = 1.0f - rc.mtlresult.transp.intensity();</div>
<div class="line">    outputRenderSample(rc, colorL / a, colorR / a, a, 0);</div>
<div class="line">        </div>
<div class="line">  </div>
<div class="line">    <span class="keywordflow">if</span> (goThrough ) { </div>
<div class="line">        rc.mtlresult.transp.makeWhite();</div>
<div class="line">        rc.mtlresult.alpha.makeZero();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeWhite();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        rc.mtlresult.transp.makeZero();</div>
<div class="line">        rc.mtlresult.alpha.makeWhite();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeZero();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Hit has been detected with an opaque surface. It will query the destination color from Left and Right eye and notify PresenZ.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeEvalOpaque(VR::VRayContext &amp;rc){</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    AutoSaveRayContextData savedRayContextData(rc);</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeResult savedMtlresult = rc.mtlresult;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isChaotic = isPrzChaoticSurface(rc, rc.rayresult);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___pz_shading_api.html#ga92c23c7b028873c784d8fd74bef4292f">PresenZ::Shading::PzIsValidEvaluation</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()), hitDistance, isChaotic) == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 0);</div>
<div class="line">        rc.mtlresult.makeOpaque(Color(0.,0.,0.));</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    deepReflection == 0 ? -&gt; false // left. (this is the former deep reflection off )</span></div>
<div class="line"><span class="comment">    deepReflection == 1 ? -&gt; false // left  (this is the former deep reflection stereoAtOnce )</span></div>
<div class="line"><span class="comment">    deepReflection == 2 ? -&gt; true  // right (new possible value to render the right eye only )  </span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> leftOrRight = presenZSettings-&gt;deepReflection == 2; <span class="comment">// if true, we bend for the right eye. </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isStereoScopicPointOfView =  bendCameraRay(rc, leftOrRight) &amp;&amp; isPrzStereoRightEye(rc, rc.rayresult) ;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if we&#39;re shading just the right eye only but this is not a stereoscopic pov, we output black for the moment...</span></div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 2 &amp;&amp; !isStereoScopicPointOfView) { </div>
<div class="line">        outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 0);</div>
<div class="line">        rc.mtlresult.makeOpaque(Color(0., 0., 0.));</div>
<div class="line">        <span class="keywordflow">return</span>;  </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">    presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The eyeray hits a full transparent surface, The resulting full transparent shade cannot be added.</span></div>
<div class="line">    <span class="comment">// In this case the eyeray continue and the shade of the transparent surface is lost. </span></div>
<div class="line">    <span class="keywordflow">if</span> (rc.mtlresult.alpha.intensity() &lt;= 0.0 &amp;&amp; rc.mtlresult.transp.intensity() &gt;= 1.0 )</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// In case the eyeray hits a matte and alpha-1 surface. a lost sample is written and the eye ray follows the path. </span></div>
<div class="line">    <span class="keywordflow">if</span> ( rc.rayresult.surfaceProps) {</div>
<div class="line">        <span class="keywordflow">if</span> (rc.rayresult.surfaceProps-&gt;matte == 1 &amp;&amp; rc.rayresult.surfaceProps-&gt;alphaContribution == -1){</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// in case the eye ray hit a transparent surface, the shade of the surfaces behind it are computed and added to the first transparent surface shade. </span></div>
<div class="line">    <span class="keywordflow">if</span> (rc.mtlresult.alpha.intensity() &lt; 1.0) {</div>
<div class="line">        traceCamRayForShadingTransparentSurface(rc, <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    rc.mtlresult.makeOpaque(rc.mtlresult.color);</div>
<div class="line">    ShadeCol originalShade = rc.mtlresult.color;</div>
<div class="line">    Color mapVrayColor = rc.vray-&gt;getSequenceDataPtr()-&gt;colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorL = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line">    <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorR = colorL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 1 &amp;&amp; isStereoScopicPointOfView) </div>
<div class="line">    {</div>
<div class="line">        savedRayContextData.restoreContext();</div>
<div class="line">        rc.mtlresult = savedMtlresult;</div>
<div class="line"> </div>
<div class="line">        bendCameraRay(rc, <span class="keyword">true</span>);</div>
<div class="line">        presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rc.mtlresult.alpha.intensity() &lt; 1.0) {</div>
<div class="line">            traceCamRayForShadingTransparentSurface(rc, <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        mapVrayColor = rc.vray-&gt;getSequenceData().colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line">        colorR = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line">            </div>
<div class="line">        rc.mtlresult.color+=originalShade; <span class="comment">// adds the left eye shade to the right eye shade in order two take in accoutn the two shade for the vray adaptation.</span></div>
<div class="line">        rc.mtlresult.color /= 2.0;</div>
<div class="line">        rc.mtlresult.makeOpaque(rc.mtlresult.color);</div>
<div class="line">    }    </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    savedRayContextData.restoreContext();</div>
<div class="line"> </div>
<div class="line">    outputRenderSample(rc, colorL, colorR, rc.mtlresult.alpha.intensity(), 0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Hit has been detected with a transparent surface. It will query the destination color from Left and Right eye but</span></div>
<div class="line"><span class="comment">// will also take into account the transparency, transmittance and reflectance at that location.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeEvalTransparent(VR::VRayContext &amp;rc) {</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isChaotic = isPrzChaoticSurface(rc, rc.rayresult);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___pz_shading_api.html#ga92c23c7b028873c784d8fd74bef4292f">PresenZ::Shading::PzIsValidEvaluation</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()), hitDistance, isChaotic) == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (isPrzBrdf(rc, rc.rayresult)){</div>
<div class="line">        shadeEvalTransparentBrdf(rc);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitPoint = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitNormal(rc.rayresult.gnormal.getUnitVector().x(), rc.rayresult.gnormal.getUnitVector().y(), rc.rayresult.gnormal.getUnitVector().z());</div>
<div class="line">    ShadeVec offset(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> goThrough = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> shadeCurrentPoint = <a class="code" href="group___pz_shading_api.html#gae26a93bf43d6cb1f25a79823ab2fe2eb">PresenZ::Shading::PzShouldShade</a>(hitPoint, hitNormal, rc.rayparams.getScreenX(), rc.rayparams.getScreenY(), goThrough);</div>
<div class="line">    <span class="keywordflow">if</span> (!shadeCurrentPoint) {</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough)</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">float</span> prz_IOR_value = 1.0;</div>
<div class="line">    <span class="keywordtype">float</span> prz_transp_value = 1.0;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// For glass surfaces shades the alpha value is overridem by a Fresnel </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isGlassSurface = checkUserAttribute(rc, rc.rayresult, VT_glassIOR, prz_IOR_value);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// On transparent surfaces the original alpha value is kept.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isTranspSurface = checkUserAttribute(rc, rc.rayresult, VT_transp, prz_transp_value);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!isGlassSurface &amp;&amp; !isTranspSurface) {</div>
<div class="line">        rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray </span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    AutoSaveRayContextData savedVrayContextData(rc);</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeResult savedMtlresult = rc.mtlresult;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    deepReflection == 0 ? -&gt; false // left. (this is the former deep reflection off )</span></div>
<div class="line"><span class="comment">    deepReflection == 1 ? -&gt; false // left  (this is the former deep reflection stereoAtOnce )</span></div>
<div class="line"><span class="comment">    deepReflection == 2 ? -&gt; true  // right (new possible value to render the right eye only )</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> leftOrRight = presenZSettings-&gt;deepReflection == 2; <span class="comment">// if true, we bend for the right eye. </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isStereoScopicPointOfView = bendCameraRay(rc, leftOrRight)  &amp;&amp; isPrzStereoRightEye(rc, rc.rayresult) ;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if we&#39;re shading just the right eye only but this is not a stereoscopic pov, we output black for the moment...</span></div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 2 &amp;&amp; !isStereoScopicPointOfView) {</div>
<div class="line">        outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 1);</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough) {</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// this GetLeftViewDir pops here because we need the leftEye view direction to compute the glass transmitance. </span></div>
<div class="line">    <span class="comment">// when we are shading transparencies, the transmitance component for each eye should be applyed to each rgb values.</span></div>
<div class="line">    <span class="comment">// But we only have one alpha channel in the PRZ. so I had to choose which transmitance value to take. the Left. for both eyes.</span></div>
<div class="line">    <a class="code" href="struct_noz_point.html">NozVector</a> V(rc.rayparams.viewDir.x(), rc.rayparams.viewDir.y(), rc.rayparams.viewDir.z());</div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 2)</div>
<div class="line">        GetLeftEyeViewDir(rc, V);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> N(rc.rayresult.normal.x(), rc.rayresult.normal.y(), rc.rayresult.normal.z());</div>
<div class="line">    <span class="keywordtype">double</span> doubleReflectance = 0.;</div>
<div class="line">    <span class="keywordtype">double</span> transmitance = 0.;</div>
<div class="line">    <a class="code" href="group___pz_shading_api.html#ga7e82f2702d8881494e22941988be4bee">PresenZ::Shading::PzGetDoubleReflectanceTransmitance</a>(doubleReflectance, transmitance, prz_transp_value, prz_IOR_value, V, N);</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeCol shadeAlpha = ShadeCol(1.0 - transmitance);</div>
<div class="line">    <span class="keywordflow">if</span> (isGlassSurface &amp;&amp; presenZSettings-&gt;my_vrayPluginMTL_list[0]) {</div>
<div class="line">        VR::MaterialInterface *VrayMtlInterface = queryInterface&lt;VUtils::MaterialInterface&gt;(presenZSettings-&gt;my_vrayPluginMTL_list[0], EXT_MATERIAL);</div>
<div class="line">        rc.mtlresult.alpha = ShadeCol(1.0);</div>
<div class="line">        rc.mtlresult.transp = rc.mtlresult.alpha.whiteComplement();</div>
<div class="line">        VrayMtlInterface-&gt;shade(rc);</div>
<div class="line">        </div>
<div class="line">        rc.mtlresult.multiply(ShadeCol(doubleReflectance), ShadeCol(1.0));</div>
<div class="line">        rc.mtlresult.alpha = shadeAlpha;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (rc.mtlresult.alpha.intensity() &lt;= 0.0 || rc.mtlresult.transp.intensity() &gt;= 1.0)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    ShadeCol originalShade = rc.mtlresult.color;</div>
<div class="line">    Color mapVrayColor = rc.vray-&gt;getSequenceDataPtr()-&gt;colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorL = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line">    <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorR = colorL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 1 &amp;&amp; isStereoScopicPointOfView ) {</div>
<div class="line"> </div>
<div class="line">        savedVrayContextData.restoreContext();</div>
<div class="line">        rc.mtlresult = savedMtlresult;</div>
<div class="line"> </div>
<div class="line">        bendCameraRay(rc, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (isGlassSurface &amp;&amp; presenZSettings-&gt;my_vrayPluginMTL_list[0]) {</div>
<div class="line">            VR::MaterialInterface *VrayMtlInterface = queryInterface&lt;VUtils::MaterialInterface&gt;(presenZSettings-&gt;my_vrayPluginMTL_list[0], EXT_MATERIAL);</div>
<div class="line">            rc.mtlresult.alpha = ShadeCol(1.0);</div>
<div class="line">            rc.mtlresult.transp = rc.mtlresult.alpha.whiteComplement();</div>
<div class="line">            VrayMtlInterface-&gt;shade(rc);</div>
<div class="line"> </div>
<div class="line">            rc.mtlresult.multiply(ShadeCol(doubleReflectance), ShadeCol(1.0));</div>
<div class="line">            rc.mtlresult.alpha = shadeAlpha;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        mapVrayColor = rc.vray-&gt;getSequenceData().colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line">        colorR = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line"> </div>
<div class="line">        rc.mtlresult.color += originalShade; <span class="comment">// adds the left eye shade to the right eye shade in order two take into account the two shades for the vray adaptation.</span></div>
<div class="line">        rc.mtlresult.color /= 2.0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Restore the rc context you change for bending and evaluating before releasing it    </span></div>
<div class="line">    savedVrayContextData.restoreContext();</div>
<div class="line">    rc.mtlresult.alpha = shadeAlpha;</div>
<div class="line">    outputRenderSample(rc, colorL, colorR, rc.mtlresult.alpha.intensity(), 1);</div>
<div class="line"> </div>
<div class="line">    ShadeCol color = rc.mtlresult.color;</div>
<div class="line">    rc.mtlresult.makeTransparent(shadeAlpha);</div>
<div class="line">    rc.mtlresult.color = color;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//rc.rayresult.wpointCoeff += 100;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (goThrough) {</div>
<div class="line">        rc.mtlresult.transp.makeWhite();</div>
<div class="line">        rc.mtlresult.alpha.makeZero();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeWhite(); </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        rc.mtlresult.transp.makeZero();</div>
<div class="line">        rc.mtlresult.alpha.makeWhite();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeZero(); </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// counterwise the former shadeEvalTransparent the reflectance and the transmitance is computed by the shader.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeEvalTransparentBrdf(VR::VRayContext &amp;rc) {</div>
<div class="line">  </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isChaotic = isPrzChaoticSurface(rc, rc.rayresult);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;hitDistance = rc.rayresult.wpointCoeff;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___pz_shading_api.html#ga92c23c7b028873c784d8fd74bef4292f">PresenZ::Shading::PzIsValidEvaluation</a>(floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()), hitDistance, isChaotic) == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitPoint = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> hitNormal(rc.rayresult.gnormal.getUnitVector().x(), rc.rayresult.gnormal.getUnitVector().y(), rc.rayresult.gnormal.getUnitVector().z());</div>
<div class="line"> </div>
<div class="line">    ShadeVec offset(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> goThrough = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> shadeCurrentPoint = <a class="code" href="group___pz_shading_api.html#gae26a93bf43d6cb1f25a79823ab2fe2eb">PresenZ::Shading::PzShouldShade</a>(hitPoint, hitNormal, rc.rayparams.getScreenX(), rc.rayparams.getScreenY(), goThrough);</div>
<div class="line">    <span class="keywordflow">if</span> (!shadeCurrentPoint) {</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough)</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    AutoSaveRayContextData savedVrayContextData(rc);</div>
<div class="line">    <span class="keyword">const</span> VR::ShadeResult savedMtlresult = rc.mtlresult;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    deepReflection == 0 ? -&gt; false // left. (this is the former deep reflection off )</span></div>
<div class="line"><span class="comment">    deepReflection == 1 ? -&gt; false // left  (this is the former deep reflection stereoAtOnce )</span></div>
<div class="line"><span class="comment">    deepReflection == 2 ? -&gt; true  // right (new possible value to render the right eye only )</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> leftOrRight = presenZSettings-&gt;deepReflection == 2; <span class="comment">// if true, we bend for the right eye. </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isStereoScopicPointOfView =  bendCameraRay(rc, leftOrRight) &amp;&amp; isPrzStereoRightEye(rc, rc.rayresult);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if we&#39;re shading just the right eye only but this is not a stereoscopic pov, we output black for the moment...</span></div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 2 &amp;&amp; !isStereoScopicPointOfView) {</div>
<div class="line">        outputRenderSample(rc, <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), <a class="code" href="struct_noz_r_g_b.html">NozRGB</a>(), 0.0f, 1);</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough) {</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line">    </div>
<div class="line">   </div>
<div class="line">    ShadeCol originalShade = rc.mtlresult.color;</div>
<div class="line">    Color mapVrayColor = rc.vray-&gt;getSequenceDataPtr()-&gt;colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorL = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line">    <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> colorR = colorL;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 1 &amp;&amp; isStereoScopicPointOfView ) {</div>
<div class="line"> </div>
<div class="line">        savedVrayContextData.restoreContext();</div>
<div class="line">        rc.mtlresult = savedMtlresult;</div>
<div class="line"> </div>
<div class="line">        bendCameraRay(rc, <span class="keyword">true</span>);</div>
<div class="line">        presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rc);</div>
<div class="line"> </div>
<div class="line">        mapVrayColor = rc.vray-&gt;getSequenceData().colorMapper-&gt;mapColor(rc.mtlresult.color.toColor(), 0, 0, <span class="keyword">false</span>);</div>
<div class="line">        colorR = <a class="code" href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a>(mapVrayColor.r, mapVrayColor.g, mapVrayColor.b);</div>
<div class="line"> </div>
<div class="line">        rc.mtlresult.color += originalShade; <span class="comment">// adds the left eye shade to the right eye shade in order two take into account the two shades for the vray adaptation.</span></div>
<div class="line">        rc.mtlresult.color /= 2.0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Restore the rc context you change for bending and evaluating before releasing it    </span></div>
<div class="line">    savedVrayContextData.restoreContext();</div>
<div class="line">    outputRenderSample(rc, colorL, colorR, rc.mtlresult.alpha.intensity(), 1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// rc.rayresult.wpointCoeff += 100;</span></div>
<div class="line">    <span class="keywordflow">if</span> (goThrough) {</div>
<div class="line">        rc.mtlresult.transp.makeWhite();</div>
<div class="line">        rc.mtlresult.alpha.makeZero();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeWhite();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        rc.mtlresult.transp.makeZero();</div>
<div class="line">        rc.mtlresult.alpha.makeWhite();</div>
<div class="line">        rc.mtlresult.alphaTransp.makeZero(); </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once we have a colorized hit intersection, we will notify PresenZ that we&#39;ve hit geometry with right/left eye colors by </span></div>
<div class="line"><span class="comment">// invoking PzProcessRenderSample.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::outputRenderSample(<span class="keyword">const</span> VRayContext &amp;rc, <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> &amp;leftColor, <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b.html">NozRGB</a> &amp;rightColor, <span class="keywordtype">float</span> alpha, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;shadeType, <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp;isMirror) {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> ShadeVec rayStat = rc.rayparams.tracedRay.p + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorldNormal = rc.rayresult.gnormal.getUnitVector();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a> normalWorld(ptWorldNormal.x(), ptWorldNormal.y(), ptWorldNormal.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozPoint</a> rayStart(rayStat.x(), rayStat.y(), rayStat.z());</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozPoint</a> hitPointWorld(ptWorld.x(), ptWorld.y(), ptWorld.z());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespace_presen_z_1_1_render_sample.html">PresenZ::RenderSample</a>;</div>
<div class="line"> </div>
<div class="line">    PzRenderSample winSample;</div>
<div class="line">    <a class="code" href="group___render_sample.html#ga5f9917e3482d27304c8a2b5da8f0d428">PzSetSamplePosition</a>(winSample, hitPointWorld);</div>
<div class="line">    <a class="code" href="group___render_sample.html#gab740a5b964a594890226fdd087c958a7">PzSetSamplePosXY</a>(winSample, rc.rayparams.getScreenX(), rc.rayparams.getScreenY());</div>
<div class="line">    <a class="code" href="group___render_sample.html#gafbfb1ad8b22bf10b7680e956b1a49edc">PzSetSampleZ</a>(winSample, <a class="code" href="group___n_o_z__vector.html#gaec436ed5ffc599d804a9fd8fb464b70d">NozVecDist</a>(hitPointWorld, rayStart));</div>
<div class="line">    <a class="code" href="group___render_sample.html#gacbfc89ad3b514c3fd64fb027ed36ebae">PzSetSampleColor</a>(winSample, <a class="code" href="struct_noz_r_g_b_a.html">NozRGBA</a>(leftColor.<a class="code" href="group___n_o_z___r_g_b_a.html#ga4788d82c901b9367dd5c0daff8a7616b">r</a>, leftColor.<a class="code" href="group___n_o_z___r_g_b_a.html#ga8cf17d727651616de6f2b79ef32170cd">g</a>, leftColor.<a class="code" href="group___n_o_z___r_g_b_a.html#ga83fc1af92e29717b4513d121b0c72c7d">b</a>, alpha));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rc.rayresult.getSurfaceHit() != 2)</div>
<div class="line">        <a class="code" href="group___render_sample.html#gaff7747e2d5786e8a2dfe81424c871f96">PzSetSampleNormal</a>(winSample, normalWorld);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (rc.mtlresult.fragment != <span class="keyword">nullptr</span> ){</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> aliasId = 0; aliasId &lt; presenZSettings-&gt;vrayRenderElementAlias.size(); aliasId++) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> alias = presenZSettings-&gt;vrayRenderElementAlias[aliasId];</div>
<div class="line">        </div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">void</span>* data = rc.mtlresult.fragment-&gt;getChannelDataPtrByAlias(<span class="keyword">static_cast&lt;</span>RegionChannelAlias<span class="keyword">&gt;</span>(alias));</div>
<div class="line">            <span class="keywordflow">if</span>(data != <span class="keyword">nullptr</span>)</div>
<div class="line">                <a class="code" href="group___render_sample.html#ga4ed240d714fdab571e1e8c73933fe63f">PzAddSampleAov</a>(winSample, data, alias);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a> || presenZSettings-&gt;glassMode != <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da7dd4b95e541632ef996ef1aeaf346dcc">PresenZ::Phase::TransparencyRenderingType::PRZ_REGULAR</a>)</div>
<div class="line">        <a class="code" href="group___render_sample.html#gac3a665a9da089d686c2ae13258d004c5">PzAddGlassSampleAov</a>(winSample, shadeType);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a4fa71226841d5dc4359c2e48fa8a079e">PresenZ::Phase::Render_Reflection</a>)</div>
<div class="line">        <a class="code" href="group___render_sample.html#gaebc69f8b1da37918174e448b587c08f9">PzAddMirrorSampleAov</a>(winSample, isMirror);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;deepReflection == 1 )</div>
<div class="line">        <a class="code" href="group___render_sample.html#ga114a179e0c69234d410fa8edd9a7b54e">PzAddRightColorSampleAov</a>(winSample, rightColor);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;hasMotionVector &amp;&amp; presenZSettings-&gt;hasVelocityChannelPresent)</div>
<div class="line">        <a class="code" href="group___render_sample.html#gae086107e0d3a7d2e8236c112691302f5">PzAddVelocitySampleAov</a>(winSample, getVrayWSVelocity(rc));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___render_sample.html#ga084dcde760df9b79018dcd35b0a8f9c5">PzAddCockpitSampleAov</a>(winSample, isPrzCockpit(rc, rc.rayresult));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___render_sample.html#ga6b0bde387f15a809ba274dd3b1e03fd8">PzSetSampleDepth</a>(winSample, rc.rayresult.getTranspLevel());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___render_sample.html#gaf31d2a3ae08ac5994f5cf02766108d75">PzProcessRenderSample</a>(rc.threadData-&gt;threadIndex, floor(rc.rayparams.getScreenX()), floor(rc.rayparams.getScreenY()), 0, winSample);</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shading with automatic detection if the target surface is Opaque/Transparent (WORK IN PROGRESS).</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeEvalOpaqueAndTransparent(VR::VRayContext &amp;rc)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> hitGlass = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (isPrzGlassSurface(rc, rc.rayresult, rc) || isPrzTranspSurface(rc, rc.rayresult, rc) || isPrzBrdfGlassSurface(rc, rc.rayresult, rc))</div>
<div class="line">        hitGlass = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    ShadeVec hit(rc.rayresult.wpoint.x(), rc.rayresult.wpoint.y(), rc.rayresult.wpoint.z());</div>
<div class="line">    ShadeVec ori(rc.rayparams.rayOrigin.x(), rc.rayparams.rayOrigin.y(), rc.rayparams.rayOrigin.z());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> hitSemiTransp = isPrzStencilSurface(rc, rc.rayresult);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___pz_detect_sample_api.html#ga4235bda2ada163773d83c4d1d6c75bc0">PresenZ::DetectSample::DetectSample_transp</a> qtransp = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> check = <a class="code" href="group___pz_shading_api.html#ga7835dda2492d50eb922bac277a1b731a">PresenZ::Shading::PzIsTransparent</a>(rc.rayparams.getScreenX(), rc.rayparams.getScreenY(), qtransp);</div>
<div class="line">    <span class="keywordflow">if</span> (!check) {</div>
<div class="line">        rc.mtlresult.makeOpaque();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (qtransp == <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53">PresenZ::DetectSample::DST_glass</a> &amp;&amp; hitGlass)</div>
<div class="line">        <span class="keywordflow">return</span> shadeEvalTransparent(rc);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (qtransp == <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a> &amp;&amp; !hitGlass &amp;&amp; !hitSemiTransp)</div>
<div class="line">        <span class="keywordflow">return</span> shadeEvalOpaque(rc);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> ( hitSemiTransp)</div>
<div class="line">        <span class="keywordflow">return</span> shadeEvalStencil(rc, qtransp);</div>
<div class="line"> </div>
<div class="line">    rc.mtlresult.transp.makeWhite();</div>
<div class="line">    rc.mtlresult.alpha.makeZero();</div>
<div class="line">    rc.mtlresult.alphaTransp.makeWhite(); <span class="comment">// make the ray transparent and keep the color for adaptative sampling.</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// During the Detection phase, we do not need to query the color at intersection. We just gather geometry </span></div>
<div class="line"><span class="comment">// information and forward these to PresenZ. PresenZ will then make additional visibility checks, for this </span></div>
<div class="line"><span class="comment">// you need to provide a RayTestInterface, so that PrensenZ can cast a visibility ray test.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZIntersectionShader::shadeDetectPhase(VR::VRayContext &amp;rc)</div>
<div class="line">{</div>
<div class="line">    RayTestInterfaceUserData userData(rc, <span class="keyword">this</span>);</div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html">PresenZ::DetectSample::RayTestInterface</a> intf;</div>
<div class="line">    intf.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html#afd0ffb02780e738d4c0a10ab833b7834">userdata</a> = &amp;userData;</div>
<div class="line">    intf.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html#a51c81d3b0c803fbfbeadb4f58c60e2d3">probe</a> = VRayRayTest;</div>
<div class="line">    intf.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html#af9b0c64fd8e21243d9d83ed8c1953a53">query</a> = VRayQueryFlags;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec hit_ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset); <span class="comment">// The point that was hit, in world space</span></div>
<div class="line">    <span class="keyword">const</span> ShadeVec hit_normalWorld = rc.rayresult.gnormal.getUnitVector();</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html">PresenZ::DetectSample::PzDetectSample</a> sample;</div>
<div class="line">    sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a75f8ddf992db0cfc3cd1aa024086b6f3">pixelX</a> = floor(rc.rayparams.getScreenX());</div>
<div class="line">    sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#aaa0423628e784003c3f5754ca1e56e70">pixelY</a> = floor(rc.rayparams.getScreenY());</div>
<div class="line">    sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a5c8e9b74c2fe744a9c5d3a12d81850cf">sampleIndex</a> = rc.rayparams.startContext-&gt;rayparams.pathVertex.currentSample;</div>
<div class="line">    sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a4c9257ffdd839b215aabfba5f05fa02e">hitNormal</a> = <a class="code" href="group___n_o_z__vector.html#ga347d85f3e636cf273a47949aa0613a8f">NozVector</a>(hit_normalWorld.x(), hit_normalWorld.y(), hit_normalWorld.z());</div>
<div class="line">    sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a39246df9bccc12078d74da138ecfbfa4">hitPoint</a> = <a class="code" href="struct_noz_point.html">NozPoint</a>(hit_ptWorld.x(), hit_ptWorld.y(), hit_ptWorld.z());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> goThrough = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> ShadeVec ptWorld = rc.rayresult.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">    ShadeVec offset(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> probeCurrentPoint = <a class="code" href="group___pz_shading_api.html#ga0b757364c38a704a0a55be31e7019a22">PresenZ::Shading::PzShouldProbe</a>(sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a39246df9bccc12078d74da138ecfbfa4">hitPoint</a>, sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a4c9257ffdd839b215aabfba5f05fa02e">hitNormal</a>, sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a75f8ddf992db0cfc3cd1aa024086b6f3">pixelX</a>, sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#aaa0423628e784003c3f5754ca1e56e70">pixelY</a>, goThrough);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!probeCurrentPoint) {</div>
<div class="line">        <span class="keywordflow">if</span> (goThrough)</div>
<div class="line">            rc.mtlresult.makeTransparent(); <span class="comment">// makes the ray transparent to continue further</span></div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            rc.mtlresult.makeOpaque(); <span class="comment">// will stop the ray</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::Detect_Reflection</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (isPrzGlassSurface(rc, rc.rayresult, rc) || isPrzTranspSurface(rc, rc.rayresult, rc))</div>
<div class="line">            sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53">PresenZ::DetectSample::DST_glass</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (presenZSettings-&gt;glassMode)</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da7dd4b95e541632ef996ef1aeaf346dcc">PresenZ::Phase::PRZ_REGULAR</a>: sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a>; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da9d90fb508b0f83e7938ec40d18de14a9">PresenZ::Phase::PRZ_OPAQUE</a>: sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a>; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da207fada585bc6f4ef37fcc78adff9960">PresenZ::Phase::PRZ_TRANSP</a>: sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53">PresenZ::DetectSample::DST_glass</a>; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4daf1fb663f950f6e485ca1a18bf9d3f2ee">PresenZ::Phase::PRZ_BOTH</a>:</div>
<div class="line">            <span class="keywordflow">if</span> (isPrzGlassSurface(rc, rc.rayresult, rc) || isPrzTranspSurface(rc, rc.rayresult, rc) || isPrzBrdfGlassSurface(rc, rc.rayresult, rc ))</div>
<div class="line">                sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53">PresenZ::DetectSample::DST_glass</a>;</div>
<div class="line">            <span class="keywordflow">else</span> </div>
<div class="line">                sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rc.rayresult.getSurfaceHit() == 2)</div>
<div class="line">    {</div>
<div class="line">        sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ad50b77be6452fcd203fa25771dd4f69e">isHair</a> = <span class="keyword">true</span>;</div>
<div class="line">        sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a4c9257ffdd839b215aabfba5f05fa02e">hitNormal</a> = <a class="code" href="group___n_o_z__vector.html#ga347d85f3e636cf273a47949aa0613a8f">NozVector</a>(0, 0, 0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (isPrzChaoticSurface(rc, rc.rayresult))</div>
<div class="line">        sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a8a33ba6ff4f3da7799e33a2827f9d297">isChaotic</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    ShadeVec hit(rc.rayresult.wpoint.x(), rc.rayresult.wpoint.y(), rc.rayresult.wpoint.z());</div>
<div class="line">    ShadeVec ori(rc.rayparams.rayOrigin.x(), rc.rayparams.rayOrigin.y(), rc.rayparams.rayOrigin.z());</div>
<div class="line">    <span class="keywordtype">float</span> shadeTransp = 0.0;</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// let&#39;s just check if the sample is locally transparent, bbut only if it&#39;s not a glass. </span></div>
<div class="line">    <span class="keywordflow">if</span> ( sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> == <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::DST_opaque</a> ) {</div>
<div class="line">        isShadeTransp(rc, ori, hit - ori , 0, presenZSettings-&gt;imageResolutionX, presenZSettings-&gt;imageResolutionY, shadeTransp);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (shadeTransp &gt;= 1.) {</div>
<div class="line">            rc.mtlresult.makeTransparent();</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shadeTransp &gt; 0.0) {</div>
<div class="line">            sample.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">transpType</a> = <a class="code" href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ac1d7b5d5d133d2381c505deeff6b457a">PresenZ::DetectSample::DST_semiTransp</a>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> &amp;threadIndex = rc.threadData-&gt;threadIndex;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_noz_r_g_b_a.html">NozRGBA</a> color = <a class="code" href="group___pz_detect_sample_api.html#gac6410e7ecfb3cf5a078a69240fc33ea8">PzProcessDetectSample</a>(&amp;intf, sample, threadIndex);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga4aec1a5be9d9a4a394a2e49e9744286e">a</a> == 0 || goThrough == <span class="keyword">true</span> || shadeTransp &gt; 0.0) {</div>
<div class="line">        rc.mtlresult.makeTransparent(ShadeCol(1.0f));</div>
<div class="line">        rc.mtlresult.color = ShadeCol(color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga4788d82c901b9367dd5c0daff8a7616b">r</a>, color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga8cf17d727651616de6f2b79ef32170cd">g</a>, color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga83fc1af92e29717b4513d121b0c72c7d">b</a>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> </div>
<div class="line">        rc.mtlresult.makeOpaque( ShadeCol(  color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga4788d82c901b9367dd5c0daff8a7616b">r</a>,color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga8cf17d727651616de6f2b79ef32170cd">g</a>,color.<a class="code" href="group___n_o_z___r_g_b_a.html#ga83fc1af92e29717b4513d121b0c72c7d">b</a> ));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef VRAYMAJOR_4</span></div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::checkUserAttribute(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData, <span class="keyword">const</span> VrayTAGs TAG, <span class="keywordtype">float</span> &amp;value)<span class="keyword"> const </span>{</div>
<div class="line">    VR::VRaySurfaceUserAttributes *sua = (VR::VRaySurfaceUserAttributes*) GET_INTERFACE(rc.rayresult.sd, EXT_SURFACE_USER_ATTRIBUTES);</div>
<div class="line">    <span class="keywordflow">if</span> (sua) {</div>
<div class="line">        <span class="keyword">const</span> tchar *prop = sua-&gt;getUserProperty(rc, VrayTAGstrs[TAG]);</div>
<div class="line">        <span class="keywordflow">if</span> (prop) {</div>
<div class="line">            value = stor(prop);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::checkUserAttribute(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData, <span class="keyword">const</span> VrayTAGs TAG, <span class="keywordtype">float</span> &amp;value)<span class="keyword"> const  </span>{</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    VR::VRaySurfaceUserAttributes *sua = VRaySurfaceUserAttributes::query(rc);</div>
<div class="line">    <span class="keywordflow">if</span> (sua) {</div>
<div class="line">        UserAttributeValue attrValue;</div>
<div class="line">        <span class="keywordflow">if</span> (sua-&gt;getUserProperty(rc, presenZSettings-&gt;VrayTAGs_SIDs[TAG], attrValue)) {</div>
<div class="line">            value = attrValue.getFloat();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isLightSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    BSDFInterface *bsdfInterface = queryInterface&lt;BSDFInterface&gt;(isData.sb, EXT_BSDF);</div>
<div class="line">    <span class="keywordflow">if</span> (!bsdfInterface) <span class="keywordflow">return</span>(queryInterface&lt;LightInterface&gt;(isData.sb, EXT_LIGHT) != <span class="keyword">nullptr</span>);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isTransparentLightSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">// this function is designed to evaluate the transparency of light to determine whether a PROBERAY will go through the light or not. </span></div>
<div class="line">    <span class="comment">// The purpose is to replicate the behavior of an eye ray for a probe ray.</span></div>
<div class="line">    <span class="keywordflow">if</span> (isLightSurface(rc, isData, rcShadable)) {        </div>
<div class="line">        presenZSettings-&gt;psdata-&gt;intersectionShader-&gt;defShade(rcShadable);</div>
<div class="line">        <span class="keywordflow">if</span> (rcShadable.mtlresult.transp.intensity() != 0.0)<span class="comment">// || rcShadable.mtlresult.alpha.intensity() != 1.0)</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;    </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzTranspSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">float</span> value = 1.0;</div>
<div class="line">    <span class="keywordflow">return</span>  checkUserAttribute(rc, isData, VT_transp, value) || checkTagByVraySSSID(rc, FSb_glassIOR);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzGlassSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">float</span> value = 1.555;</div>
<div class="line">    <span class="keywordflow">return</span> checkUserAttribute(rc, isData, VT_glassIOR, value) || checkTagByVraySSSID(rc, FSb_glassIOR);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzChaoticSurface(VR::VRayContext&amp; rc, IntersectionData &amp;isData)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">float</span> value = 1.0;</div>
<div class="line">    <span class="keywordflow">return</span> checkTagByVraySSSID(rc, FSb_chaotic) || checkUserAttribute(rc, isData, VT_chaotic, value);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzStencilSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">float</span> value = 1.0;</div>
<div class="line">    <span class="keywordflow">return</span> checkTagByVraySSSID(rc, FSb_stencil) || checkUserAttribute(rc, isData, VT_stencil, value);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzIsolatedSurface(VR::VRayContext&amp; rc, IntersectionData &amp;isData)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">float</span> value = 1.0;</div>
<div class="line">    <span class="keywordflow">return</span> checkTagByVraySSSID(rc, FSb_isolated) || checkUserAttribute(rc, isData, VT_isolated, value);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzBrdfGlassSurface(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> isPrzBrdf(rc, isData);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzStereoRightEye(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;stereoRightEye == 0) {  <span class="comment">// all surfaces can be rendered as stereo</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;stereoRightEye == 1 ) {  <span class="comment">// tagged surfaces only can be rendered as stereo</span></div>
<div class="line">        <span class="keywordtype">float</span> value = 1.0;</div>
<div class="line">        <span class="keywordflow">return</span> checkTagByVraySSSID(rc, FSb_stereo) || checkUserAttribute(rc, isData, VT_stereo, value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (presenZSettings-&gt;stereoRightEye == 2) {  <span class="comment">// NON tagged surfaces only can be rendered as stereo</span></div>
<div class="line">        <span class="keywordtype">float</span> value = 1.0;</div>
<div class="line">        <span class="keywordflow">return</span> !( checkTagByVraySSSID(rc, FSb_stereo) || checkUserAttribute(rc, isData, VT_stereo, value) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzBrdf(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> IntersectionData &amp;isData)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// rendering standalone, the PresenZ Material can be directly accessed with its EXT_DEFAULT_SHADE_DATA interface which let us get its materialRenderId </span></div>
<div class="line">    <span class="comment">// this way we avoid to export surface tag which are not necessary in the vrscene.</span></div>
<div class="line">    DefaultVRayShadeData *sd = <span class="keyword">static_cast&lt;</span>DefaultVRayShadeData*<span class="keyword">&gt;</span>GET_INTERFACE(rc.rayresult.sd, EXT_DEFAULT_SHADE_DATA);</div>
<div class="line">    <span class="keywordflow">if</span> (sd) {</div>
<div class="line">        <span class="keywordflow">if</span> (sd-&gt;getMaterialRenderID(rc) == 2018101195)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// otherwise when we&#39;re rendering directly in 3dsmax the EXT_DEFAULT_SHADE_DATA interface is no accesible, thus we check if a tag is set on the surface</span></div>
<div class="line">    <span class="keywordtype">float</span> value;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> przBrdfGlass = checkUserAttribute(rc, isData, VT_glassbrdf, value);</div>
<div class="line">    <span class="keywordflow">return</span> przBrdfGlass;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::isPrzCockpit(<span class="keyword">const</span> VR::VRayContext&amp; rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">float</span> value;</div>
<div class="line">    <span class="keywordflow">return</span> checkUserAttribute(rc, isData, VT_cockpit, value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> PresenZIntersectionShader::checkIfSurfaceIs(<span class="keyword">const</span> checkSurfaceFuncArray &amp;functionContainer, <span class="keyword">const</span> VR::VRayContext &amp;rc, <span class="keyword">const</span> VR::IntersectionData &amp;isData, VR::VRayContext&amp; rcShadable)<span class="keyword">  const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">for</span> (checkSurfaceFuncArray::const_iterator fctPtrIt = functionContainer.begin(); fctPtrIt != functionContainer.end(); fctPtrIt++)</div>
<div class="line">        <span class="keywordflow">if</span>((this-&gt;*(*fctPtrIt))(rc, isData, rcShadable))</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Probing interface: PrensenZ detection phase needs a mechanism to perform an</span></div>
<div class="line"><span class="comment">// additional visibility check when a surface intersection is detected. </span></div>
<div class="line"><span class="comment">// RayTestInterfaceHitTest is given to PresenZ as a callback with userData </span></div>
<div class="line"><span class="comment">// pointer.</span></div>
<div class="line"> </div>
<div class="line">RayTestResult::RayTestResult()</div>
<div class="line">{</div>
<div class="line">    hitLocation = <a class="code" href="group___n_o_z__vector.html#ga7903754d0a199b066fbe319c3016545c">nozPoint</a>(0, 0, 0);</div>
<div class="line">    hitNormal = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(0, 0, 0);</div>
<div class="line">    hitDistance = 0.0f;</div>
<div class="line">    hasHit = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint64_t VRayQueryFlags(uint64_t flags, <span class="keywordtype">void</span>* userData) { <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This is the callback that is invoked by PresenZ</span></div>
<div class="line"><span class="keywordtype">bool</span> VRayRayTest(<span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; origin, <span class="keyword">const</span> <a class="code" href="struct_noz_point.html">NozVector</a>&amp; dir, <span class="keyword">const</span> <span class="keywordtype">double</span> dist, <a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html">PresenZ::DetectSample::RayTestResult</a>&amp; out, <span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    RayTestInterfaceUserData&amp; context = *<span class="keyword">reinterpret_cast&lt;</span>RayTestInterfaceUserData*<span class="keyword">&gt;</span>(userData);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using namespace </span>VUtils;</div>
<div class="line">    <span class="keyword">const</span> TracePoint&amp; sceneOffset = context.m_rc.vray-&gt;getFrameData().sceneOffset;</div>
<div class="line">    <span class="keyword">const</span> RayTestResult result = context.m_shader-&gt;RayTest(context.m_rc, ShadeVec(origin.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, origin.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, origin.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>) - ShadeVec(sceneOffset), ShadeVec(dir.<a class="code" href="group___n_o_z__vector.html#gad0da36b2558901e21e7a30f6c227a45e">x</a>, dir.<a class="code" href="group___n_o_z__vector.html#gaa4f0d3eebc3c443f9be81bf48561a217">y</a>, dir.<a class="code" href="group___n_o_z__vector.html#gaf73583b1e980b0aa03f9884812e9fd4d">z</a>), dist);</div>
<div class="line">    <span class="keywordflow">if</span> (result.hasHit)</div>
<div class="line">    {</div>
<div class="line">        out.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a9d3ba7a09d203fbcadc59723666e37fe">hit</a> = result.hitLocation;</div>
<div class="line">        out.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a58649588b953a60c4ab3fb9b2143a87b">normal</a> = result.hitNormal;</div>
<div class="line">        out.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> = result.hitDistance;</div>
<div class="line">        out.<a class="code" href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a8a33ba6ff4f3da7799e33a2827f9d297">isChaotic</a> = result.isChaotic;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> result.hasHit;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function will check visibility of an intersection during detection phase in order to guess occlusions. It will </span></div>
<div class="line"><span class="comment">// go through invisible surfaces (surfaces will be discarded by m_invisibleForProbeRay).</span></div>
<div class="line">RayTestResult PresenZIntersectionShader::RayTest(VRayContext &amp;rc, <span class="keyword">const</span> ShadeVec &amp;pt, <span class="keyword">const</span> ShadeVec &amp;dir, <span class="keywordtype">double</span> maxDist)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> originalImpactDistance = (rc.rayresult.wpoint - pt).length();</div>
<div class="line">    VRayContext &amp;nrc = rc.newSpawnContext(0, ShadeCol(1.0f, 1.0f, 1.0f), VR::RayFlags(0), dir.getUnitVector());</div>
<div class="line">    IntersectionData isData;</div>
<div class="line">    RayTestResult result; <span class="comment">// false by default</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (presenZSettings-&gt;currentPhase == <a class="code" href="group___pz_phase_api.html#ggae1c5184dc404edf057ed537bcfddef84a9e72290cbba5243f4449f84168a3c99c">PresenZ::Phase::Detect_Reflection</a>)</div>
<div class="line">        nrc.setTracedRay(TraceRay(pt, dir.getUnitVector()), 0.0f, maxDist, <span class="keyword">true</span>, rc.rayresult.skipTag);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        nrc.setTracedRay(TraceRay(pt, dir.getUnitVector()), 0.0f, maxDist, <span class="keyword">false</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">    isData.clear();</div>
<div class="line"> </div>
<div class="line">    ShadeVec shadeTranspOri = pt;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VRAY_MAXRECURSION; i++) </div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> hit = nrc.vray-&gt;findIntersection(nrc, &amp;isData);</div>
<div class="line">        <span class="keywordflow">if</span> (hit == 1) </div>
<div class="line">        {</div>
<div class="line">            nrc.setRayResult(hit, &amp;isData);</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">            float curDist = (isData.wpoint - pt).length();</span></div>
<div class="line"><span class="comment">            float newcurDist = curDist;</span></div>
<div class="line"><span class="comment">            if ((curDist &lt;= previousHitDist) &amp;&amp; maxDist &gt;= NOZ_MAXRAYBACK) { //if we hit same object again, this might happen if we are shooting rays from a large distance, we increase the offset from which to start shooting the ray</span></div>
<div class="line"><span class="comment">                PZ_WARNING_TEST_ONLYONCE(true, &quot;Hitting the same surface multiple times without continuing the ray throuh the surface. This is probably due to Vray rounding values at large distances.&quot;);</span></div>
<div class="line"><span class="comment">                while ((newcurDist == curDist || newcurDist == previousHitDist) &amp;&amp; (nrc.rayparams.mint &lt; maxDist)) {//inrease with 10 the offset until e don&#39;t hit the same point anymore</span></div>
<div class="line"><span class="comment">                    nrc.rayparams.mint = nrc.rayparams.mint + 10.0;</span></div>
<div class="line"><span class="comment">                    nrc.vray-&gt;findIntersection(nrc, &amp;isData);</span></div>
<div class="line"><span class="comment">                    newcurDist = (isData.wpoint - pt).length();</span></div>
<div class="line"><span class="comment">                }</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">            curDist = newcurDist;</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">            <span class="comment">// We go through invisible surfaces UNLESS we are at proximity of the original impact.</span></div>
<div class="line"> </div>
<div class="line">            ShadeVec hit( isData.wpoint );</div>
<div class="line">            ShadeVec ori (shadeTranspOri );</div>
<div class="line">            <span class="keywordtype">float</span> shadeTransp = 0.0;</div>
<div class="line">            isShadeTransp(nrc, ori, hit - ori, 10.0, presenZSettings-&gt;imageResolutionX, presenZSettings-&gt;imageResolutionY, shadeTransp);</div>
<div class="line">            <span class="keywordtype">float</span> nDist = (isData.wpoint - pt).length();</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> znotmatter = !PresenZ::Utils::zMatters_fast_hard(originalImpactDistance, nDist, 5.0);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> sameSurfaceThanCamRayHit = (rc.rayresult.skipTag == isData.skipTag) || (znotmatter);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">bool</span> contv = (shadeTransp &gt; 0. ) &amp;&amp; (!sameSurfaceThanCamRayHit);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span>(contv || checkIfSurfaceIs(m_invisibleForProbeRay, nrc, isData, nrc) )</div>
<div class="line">            {</div>
<div class="line">                nrc.rayparams.skipTag = isData.skipTag;</div>
<div class="line">                nrc.rayparams.mint = isData.wpointCoeff + <a class="code" href="constant_8h.html#a107c67dbf6a4414eb77ada645a15dd9a">NOZ_EPSILON</a>;</div>
<div class="line">                shadeTranspOri = isData.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset);</div>
<div class="line">                <span class="comment">//previousHitDist = curDist;</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> ShadeVec hitPtWorld = isData.wpoint + ShadeVec(rc.vray-&gt;getFrameData().sceneOffset); <span class="comment">// The hit point in world space</span></div>
<div class="line">                <span class="keyword">const</span> ShadeVec hitNormal = isData.gnormal.getUnitVector(); <span class="comment">// The hit normal in world space</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> isChaotic = isPrzChaoticSurface(nrc, isData);</div>
<div class="line"> </div>
<div class="line">                result.hasHit = <span class="keyword">true</span>;</div>
<div class="line">                result.hitLocation = <a class="code" href="group___n_o_z__vector.html#ga7903754d0a199b066fbe319c3016545c">nozPoint</a>(hitPtWorld.x(), hitPtWorld.y(), hitPtWorld.z());</div>
<div class="line">                result.hitNormal = <a class="code" href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a>(hitNormal.x(), hitNormal.y(), hitNormal.z());</div>
<div class="line">                result.hitDistance = isData.wpointCoeff * dir.length();</div>
<div class="line">                result.isChaotic = isChaotic;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    nrc.releaseContext();</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="a_pz_assert_8h_html"><div class="ttname"><a href="_pz_assert_8h.html">PzAssert.h</a></div><div class="ttdoc">Several helper macros for validating and debugging using PresenZ logging system.</div></div>
<div class="ttc" id="a_pz_render_sample_api_8h_html"><div class="ttname"><a href="_pz_render_sample_api_8h.html">PzRenderSampleApi.h</a></div></div>
<div class="ttc" id="a_pz_shading_api_8h_html"><div class="ttname"><a href="_pz_shading_api_8h.html">PzShadingApi.h</a></div></div>
<div class="ttc" id="aconstant_8h_html_a107c67dbf6a4414eb77ada645a15dd9a"><div class="ttname"><a href="constant_8h.html#a107c67dbf6a4414eb77ada645a15dd9a">NOZ_EPSILON</a></div><div class="ttdeci">#define NOZ_EPSILON</div><div class="ttdef"><b>Definition:</b> constant.h:15</div></div>
<div class="ttc" id="agroup___n_o_z___r_g_b_a_html_ga2a92bf0c88422e170d7f91b07dfacd9a"><div class="ttname"><a href="group___n_o_z___r_g_b_a.html#ga2a92bf0c88422e170d7f91b07dfacd9a">nozRGB</a></div><div class="ttdeci">NozRGB nozRGB(float f)</div><div class="ttdoc">Create a RGB color using the same value for all components.</div><div class="ttdef"><b>Definition:</b> color.h:578</div></div>
<div class="ttc" id="agroup___n_o_z___r_g_b_a_html_ga4788d82c901b9367dd5c0daff8a7616b"><div class="ttname"><a href="group___n_o_z___r_g_b_a.html#ga4788d82c901b9367dd5c0daff8a7616b">NozRGB::r</a></div><div class="ttdeci">float r</div><div class="ttdoc">red</div><div class="ttdef"><b>Definition:</b> color.h:90</div></div>
<div class="ttc" id="agroup___n_o_z___r_g_b_a_html_ga4aec1a5be9d9a4a394a2e49e9744286e"><div class="ttname"><a href="group___n_o_z___r_g_b_a.html#ga4aec1a5be9d9a4a394a2e49e9744286e">NozRGBA::a</a></div><div class="ttdeci">float a</div><div class="ttdoc">alpha</div><div class="ttdef"><b>Definition:</b> color.h:320</div></div>
<div class="ttc" id="agroup___n_o_z___r_g_b_a_html_ga83fc1af92e29717b4513d121b0c72c7d"><div class="ttname"><a href="group___n_o_z___r_g_b_a.html#ga83fc1af92e29717b4513d121b0c72c7d">NozRGB::b</a></div><div class="ttdeci">float b</div><div class="ttdoc">blue</div><div class="ttdef"><b>Definition:</b> color.h:94</div></div>
<div class="ttc" id="agroup___n_o_z___r_g_b_a_html_ga8cf17d727651616de6f2b79ef32170cd"><div class="ttname"><a href="group___n_o_z___r_g_b_a.html#ga8cf17d727651616de6f2b79ef32170cd">NozRGB::g</a></div><div class="ttdeci">float g</div><div class="ttdoc">green</div><div class="ttdef"><b>Definition:</b> color.h:92</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_ga19bf5d776ee066f688d5432fe9ce257f"><div class="ttname"><a href="group___n_o_z__vector.html#ga19bf5d776ee066f688d5432fe9ce257f">NozVecNormalize</a></div><div class="ttdeci">NozVector NozVecNormalize(const NozVector &amp;a)</div><div class="ttdoc">Normalize a vector: a / ||a||.</div><div class="ttdef"><b>Definition:</b> vector.h:622</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_ga28a60e393933a7a2d9ea26106d74b8e1"><div class="ttname"><a href="group___n_o_z__vector.html#ga28a60e393933a7a2d9ea26106d74b8e1">NozVecDot</a></div><div class="ttdeci">float NozVecDot(const NozVector2 &amp;v1, const NozVector2 &amp;v2)</div><div class="ttdoc">Dot product: &lt;v1, v2&gt;</div><div class="ttdef"><b>Definition:</b> vector.h:464</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_ga347d85f3e636cf273a47949aa0613a8f"><div class="ttname"><a href="group___n_o_z__vector.html#ga347d85f3e636cf273a47949aa0613a8f">NozVector</a></div><div class="ttdeci">NozPoint NozVector</div><div class="ttdoc">3D vector (single precision)</div><div class="ttdef"><b>Definition:</b> vector.h:435</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_ga67d23b8a9bee957caefe96759f6b012c"><div class="ttname"><a href="group___n_o_z__vector.html#ga67d23b8a9bee957caefe96759f6b012c">nozVector</a></div><div class="ttdeci">NozVector nozVector(float x, float y, float z)</div><div class="ttdoc">Create a XYZ vector from its components (same as NozPoint)</div><div class="ttdef"><b>Definition:</b> vector.h:525</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_ga7903754d0a199b066fbe319c3016545c"><div class="ttname"><a href="group___n_o_z__vector.html#ga7903754d0a199b066fbe319c3016545c">nozPoint</a></div><div class="ttdeci">NozPoint nozPoint(float x, float y, float z)</div><div class="ttdoc">Create a XYZ point from its components.</div><div class="ttdef"><b>Definition:</b> vector.h:517</div></div>
<div class="ttc" id="agroup___n_o_z__vector_html_gaec436ed5ffc599d804a9fd8fb464b70d"><div class="ttname"><a href="group___n_o_z__vector.html#gaec436ed5ffc599d804a9fd8fb464b70d">NozVecDist</a></div><div class="ttdeci">float NozVecDist(const NozPoint2 &amp;p1, const NozPoint2 &amp;p2)</div><div class="ttdoc">Distance between two points: ||p1-p2||.</div><div class="ttdef"><b>Definition:</b> vector.h:480</div></div>
<div class="ttc" id="agroup___pz_detect_sample_api_html_gac6410e7ecfb3cf5a078a69240fc33ea8"><div class="ttname"><a href="group___pz_detect_sample_api.html#gac6410e7ecfb3cf5a078a69240fc33ea8">PresenZ::DetectSample::v3_0::PzProcessDetectSample</a></div><div class="ttdeci">NozRGBA PzProcessDetectSample(RayTestInterface *intfPtr, const PzDetectSample &amp;sample, const size_t &amp;threadIndex)</div><div class="ttdoc">During the detection phase, ray intersections need to be notified to PresenZ through PzProcessDetectS...</div></div>
<div class="ttc" id="agroup___pz_detect_sample_api_html_gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef"><div class="ttname"><a href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0a764df783476834077c68894c4c3be2ef">PresenZ::DetectSample::v3_0::DST_opaque</a></div><div class="ttdeci">@ DST_opaque</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:74</div></div>
<div class="ttc" id="agroup___pz_detect_sample_api_html_gga4235bda2ada163773d83c4d1d6c75bc0ac1d7b5d5d133d2381c505deeff6b457a"><div class="ttname"><a href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ac1d7b5d5d133d2381c505deeff6b457a">PresenZ::DetectSample::v3_0::DST_semiTransp</a></div><div class="ttdeci">@ DST_semiTransp</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:76</div></div>
<div class="ttc" id="agroup___pz_detect_sample_api_html_gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53"><div class="ttname"><a href="group___pz_detect_sample_api.html#gga4235bda2ada163773d83c4d1d6c75bc0ae0e0d5fadce4b0933385ee555c8f7a53">PresenZ::DetectSample::v3_0::DST_glass</a></div><div class="ttdeci">@ DST_glass</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:75</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_ga3104904c134a52357b85f763f6dfd48f"><div class="ttname"><a href="group___pz_phase_api.html#ga3104904c134a52357b85f763f6dfd48f">PresenZ::Phase::v3_0::Eye</a></div><div class="ttdeci">Eye</div><div class="ttdoc">Eye describes for which eye we are rendering, this is used in PresenZ to bend rays correctly.</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:57</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_gga3104904c134a52357b85f763f6dfd48fa4280d82f18d6dbafdeb68c811112455e"><div class="ttname"><a href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fa4280d82f18d6dbafdeb68c811112455e">PresenZ::Phase::v3_0::RC_Left</a></div><div class="ttdeci">@ RC_Left</div><div class="ttdoc">render left eye</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:61</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_gga3104904c134a52357b85f763f6dfd48fac2b22af1f16cebd2cc909767c763a713"><div class="ttname"><a href="group___pz_phase_api.html#gga3104904c134a52357b85f763f6dfd48fac2b22af1f16cebd2cc909767c763a713">PresenZ::Phase::v3_0::RC_Right</a></div><div class="ttdeci">@ RC_Right</div><div class="ttdoc">render right eye</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:63</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_gga36a74ae11377f0edba8dcb5070390a4da207fada585bc6f4ef37fcc78adff9960"><div class="ttname"><a href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da207fada585bc6f4ef37fcc78adff9960">PresenZ::Phase::v3_0::PRZ_TRANSP</a></div><div class="ttdeci">@ PRZ_TRANSP</div><div class="ttdoc">glass only</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:51</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_gga36a74ae11377f0edba8dcb5070390a4da7dd4b95e541632ef996ef1aeaf346dcc"><div class="ttname"><a href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da7dd4b95e541632ef996ef1aeaf346dcc">PresenZ::Phase::v3_0::PRZ_REGULAR</a></div><div class="ttdeci">@ PRZ_REGULAR</div><div class="ttdoc">glass rendering mode is off</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:47</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_gga36a74ae11377f0edba8dcb5070390a4da9d90fb508b0f83e7938ec40d18de14a9"><div class="ttname"><a href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4da9d90fb508b0f83e7938ec40d18de14a9">PresenZ::Phase::v3_0::PRZ_OPAQUE</a></div><div class="ttdeci">@ PRZ_OPAQUE</div><div class="ttdoc">opaque only</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:49</div></div>
<div class="ttc" id="agroup___pz_phase_api_html_gga36a74ae11377f0edba8dcb5070390a4daf1fb663f950f6e485ca1a18bf9d3f2ee"><div class="ttname"><a href="group___pz_phase_api.html#gga36a74ae11377f0edba8dcb5070390a4daf1fb663f950f6e485ca1a18bf9d3f2ee">PresenZ::Phase::v3_0::PRZ_BOTH</a></div><div class="ttdeci">@ PRZ_BOTH</div><div class="ttdoc">Both, if the renderer support it.</div><div class="ttdef"><b>Definition:</b> PzPhaseApi.h:53</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga0b757364c38a704a0a55be31e7019a22"><div class="ttname"><a href="group___pz_shading_api.html#ga0b757364c38a704a0a55be31e7019a22">PresenZ::Shading::v3_0::PzShouldProbe</a></div><div class="ttdeci">bool PzShouldProbe(const NozPoint &amp;hitPointWorld, const NozVector &amp;hitPointNormal, const double &amp;x, const double &amp;y, bool &amp;goThrough)</div><div class="ttdoc">During the detection phase, check if we need to sample the shader of the current sampling point for t...</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga37c6f602200a7c66975426ba37d7ed5f"><div class="ttname"><a href="group___pz_shading_api.html#ga37c6f602200a7c66975426ba37d7ed5f">PresenZ::Shading::v3_0::PzGetReflectionDirection</a></div><div class="ttdeci">NozVector PzGetReflectionDirection(const NozVector incomingDirectionWorld, const double &amp;x, const double &amp;y)</div><div class="ttdoc">Get the reflection direction for the current ray direction for RENDER_REFLECTION phase.</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga6478fef8d991dafb6f7568600f57cf9c"><div class="ttname"><a href="group___pz_shading_api.html#ga6478fef8d991dafb6f7568600f57cf9c">PresenZ::Shading::v3_0::PzGetTranspRayRenderPhase</a></div><div class="ttdeci">PzBendRayEx PzGetTranspRayRenderPhase(const PresenZ::Phase::Eye eye, const NozVector &amp;normal, const NozVector &amp;worldCameraDir, const NozPoint &amp;worldPoint, const double &amp;hitDistance)</div><div class="ttdoc">get a ray bent from the specular point to spawn a new camera ray from the current shading context.</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga7835dda2492d50eb922bac277a1b731a"><div class="ttname"><a href="group___pz_shading_api.html#ga7835dda2492d50eb922bac277a1b731a">PresenZ::Shading::v3_0::PzIsTransparent</a></div><div class="ttdeci">bool PzIsTransparent(const double &amp;x, const double &amp;y, DetectSample::DetectSample_transp &amp;transpType)</div><div class="ttdoc">Query PresenZ to know if the current location should be shaded as Transparent or not.</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga7b1e9d6ef33e499eca978c3dba837d98"><div class="ttname"><a href="group___pz_shading_api.html#ga7b1e9d6ef33e499eca978c3dba837d98">PresenZ::Shading::v3_0::PzGetBestCameraWSPosition</a></div><div class="ttdeci">NozPoint PzGetBestCameraWSPosition(const int &amp;pixelX, const int &amp;pixelY)</div><div class="ttdoc">Get the world position of the current scanning camera (the best camera selected for scanning this poi...</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga7e82f2702d8881494e22941988be4bee"><div class="ttname"><a href="group___pz_shading_api.html#ga7e82f2702d8881494e22941988be4bee">PresenZ::Shading::v3_0::PzGetDoubleReflectanceTransmitance</a></div><div class="ttdeci">bool PzGetDoubleReflectanceTransmitance(double &amp;outReflectance, double &amp;outTransmitance, const double &amp;glassTransparency, const double &amp;glassIOR, const NozVector &amp;incident, const NozVector &amp;normal)</div><div class="ttdoc">Get the reflectance and transmittance value for a double sided PresenZ surface.</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_ga92c23c7b028873c784d8fd74bef4292f"><div class="ttname"><a href="group___pz_shading_api.html#ga92c23c7b028873c784d8fd74bef4292f">PresenZ::Shading::v3_0::PzIsValidEvaluation</a></div><div class="ttdeci">bool PzIsValidEvaluation(const int &amp;pixelX, const int &amp;pixelY, const double &amp;hitDistance, bool isChaotic=false)</div><div class="ttdoc">Query PresenZ to know if the current location should be shaded.</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_gab494b6706b2ce7119c4736a70bd6f594"><div class="ttname"><a href="group___pz_shading_api.html#gab494b6706b2ce7119c4736a70bd6f594">PresenZ::Shading::v3_0::PzGetBendRayRenderPhase</a></div><div class="ttdeci">PzBendRay PzGetBendRayRenderPhase(const PresenZ::Phase::Eye &amp;eye, const NozVector &amp;GNormal, const NozVector &amp;normal, const NozVector &amp;CameraDir, const NozPoint &amp;hitPoint, const double &amp;hitDistance, const NozVector &amp;bestCamWsPos)</div><div class="ttdoc">Get a ray bent from the specular point to override the shading context.</div></div>
<div class="ttc" id="agroup___pz_shading_api_html_gae26a93bf43d6cb1f25a79823ab2fe2eb"><div class="ttname"><a href="group___pz_shading_api.html#gae26a93bf43d6cb1f25a79823ab2fe2eb">PresenZ::Shading::v3_0::PzShouldShade</a></div><div class="ttdeci">bool PzShouldShade(const NozPoint &amp;hitPointWorld, const NozVector &amp;hitPointNormal, const double &amp;x, const double &amp;y, bool &amp;goThrough)</div><div class="ttdoc">Query PresenZ to know if the current location should be shaded as Transparent or not.</div></div>
<div class="ttc" id="agroup___render_sample_html_ga084dcde760df9b79018dcd35b0a8f9c5"><div class="ttname"><a href="group___render_sample.html#ga084dcde760df9b79018dcd35b0a8f9c5">PresenZ::RenderSample::v3_0::PzAddCockpitSampleAov</a></div><div class="ttdeci">void PzAddCockpitSampleAov(PzRenderSample &amp;sample, const bool &amp;cockpit)</div><div class="ttdoc">will tag the current sample to be in the camera space to avoid interpolation when the camera is movin...</div></div>
<div class="ttc" id="agroup___render_sample_html_ga114a179e0c69234d410fa8edd9a7b54e"><div class="ttname"><a href="group___render_sample.html#ga114a179e0c69234d410fa8edd9a7b54e">PresenZ::RenderSample::v3_0::PzAddRightColorSampleAov</a></div><div class="ttdeci">void PzAddRightColorSampleAov(PzRenderSample &amp;sample, const NozRGB &amp;rightColor)</div><div class="ttdoc">Will tag the current sample with a different color if it has been seen by the right eye.</div></div>
<div class="ttc" id="agroup___render_sample_html_ga4ed240d714fdab571e1e8c73933fe63f"><div class="ttname"><a href="group___render_sample.html#ga4ed240d714fdab571e1e8c73933fe63f">PresenZ::RenderSample::v3_0::PzAddSampleAov</a></div><div class="ttdeci">void PzAddSampleAov(PzRenderSample &amp;sample, const void *data, const int &amp;iAlias)</div><div class="ttdoc">Add your own custom type of data.</div></div>
<div class="ttc" id="agroup___render_sample_html_ga5f9917e3482d27304c8a2b5da8f0d428"><div class="ttname"><a href="group___render_sample.html#ga5f9917e3482d27304c8a2b5da8f0d428">PresenZ::RenderSample::v3_0::PzSetSamplePosition</a></div><div class="ttdeci">void PzSetSamplePosition(PzRenderSample &amp;sample, const NozPoint &amp;position)</div><div class="ttdoc">Set the sample position.</div></div>
<div class="ttc" id="agroup___render_sample_html_ga6b0bde387f15a809ba274dd3b1e03fd8"><div class="ttname"><a href="group___render_sample.html#ga6b0bde387f15a809ba274dd3b1e03fd8">PresenZ::RenderSample::v3_0::PzSetSampleDepth</a></div><div class="ttdeci">void PzSetSampleDepth(PzRenderSample &amp;sample, const int &amp;depth)</div><div class="ttdoc">Will reference the depth of the current sample (transparency level) for filtering.</div></div>
<div class="ttc" id="agroup___render_sample_html_gab740a5b964a594890226fdd087c958a7"><div class="ttname"><a href="group___render_sample.html#gab740a5b964a594890226fdd087c958a7">PresenZ::RenderSample::v3_0::PzSetSamplePosXY</a></div><div class="ttdeci">void PzSetSamplePosXY(PzRenderSample &amp;sample, const double &amp;xScreen, const double &amp;yScreen)</div><div class="ttdoc">Set the X/Y inside the pixel, this will set the inPixelPosXY by keeping only the decimals.</div></div>
<div class="ttc" id="agroup___render_sample_html_gac3a665a9da089d686c2ae13258d004c5"><div class="ttname"><a href="group___render_sample.html#gac3a665a9da089d686c2ae13258d004c5">PresenZ::RenderSample::v3_0::PzAddGlassSampleAov</a></div><div class="ttdeci">void PzAddGlassSampleAov(PzRenderSample &amp;sample, const int &amp;glass)</div><div class="ttdoc">Will tag the current sample as a glass that need to be transparent.</div></div>
<div class="ttc" id="agroup___render_sample_html_gacbfc89ad3b514c3fd64fb027ed36ebae"><div class="ttname"><a href="group___render_sample.html#gacbfc89ad3b514c3fd64fb027ed36ebae">PresenZ::RenderSample::v3_0::PzSetSampleColor</a></div><div class="ttdeci">void PzSetSampleColor(PzRenderSample &amp;sample, const NozRGBA &amp;rgba)</div><div class="ttdoc">Set the default (left eye) color for this sample.</div></div>
<div class="ttc" id="agroup___render_sample_html_gae086107e0d3a7d2e8236c112691302f5"><div class="ttname"><a href="group___render_sample.html#gae086107e0d3a7d2e8236c112691302f5">PresenZ::RenderSample::v3_0::PzAddVelocitySampleAov</a></div><div class="ttdeci">void PzAddVelocitySampleAov(PzRenderSample &amp;sample, const NozVector &amp;velocity)</div><div class="ttdoc">Will tag the current sample with a specific velocity so between-frame interpolation is more accurate.</div></div>
<div class="ttc" id="agroup___render_sample_html_gaebc69f8b1da37918174e448b587c08f9"><div class="ttname"><a href="group___render_sample.html#gaebc69f8b1da37918174e448b587c08f9">PresenZ::RenderSample::v3_0::PzAddMirrorSampleAov</a></div><div class="ttdeci">void PzAddMirrorSampleAov(PzRenderSample &amp;sample, const bool &amp;mirror)</div><div class="ttdoc">Will tag the current sample as a mirror for RT reflections.</div></div>
<div class="ttc" id="agroup___render_sample_html_gaf31d2a3ae08ac5994f5cf02766108d75"><div class="ttname"><a href="group___render_sample.html#gaf31d2a3ae08ac5994f5cf02766108d75">PresenZ::RenderSample::v3_0::PzProcessRenderSample</a></div><div class="ttdeci">void PzProcessRenderSample(const size_t &amp;bucketId, const int &amp;pixelX, const int &amp;pixelY, size_t depth, PzRenderSample &amp;inSample)</div><div class="ttdoc">Forward the current RenderSample data to PresenZ bucket.</div></div>
<div class="ttc" id="agroup___render_sample_html_gafbfb1ad8b22bf10b7680e956b1a49edc"><div class="ttname"><a href="group___render_sample.html#gafbfb1ad8b22bf10b7680e956b1a49edc">PresenZ::RenderSample::v3_0::PzSetSampleZ</a></div><div class="ttdeci">void PzSetSampleZ(PzRenderSample &amp;sample, const double z)</div><div class="ttdoc">Set how far from the ray origin you are.</div></div>
<div class="ttc" id="agroup___render_sample_html_gaff7747e2d5786e8a2dfe81424c871f96"><div class="ttname"><a href="group___render_sample.html#gaff7747e2d5786e8a2dfe81424c871f96">PresenZ::RenderSample::v3_0::PzSetSampleNormal</a></div><div class="ttdeci">void PzSetSampleNormal(PzRenderSample &amp;sample, const NozVector &amp;normal)</div><div class="ttdoc">Set the sample normal.</div></div>
<div class="ttc" id="anamespace_presen_z_1_1_render_sample_html"><div class="ttname"><a href="namespace_presen_z_1_1_render_sample.html">PresenZ::RenderSample</a></div><div class="ttdef"><b>Definition:</b> PzRenderSampleApi.h:16</div></div>
<div class="ttc" id="astruct_noz_r_g_b_a_html"><div class="ttname"><a href="struct_noz_r_g_b_a.html">NozRGBA</a></div><div class="ttdoc">RGB color + alpha.</div><div class="ttdef"><b>Definition:</b> color.h:312</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html">PresenZ::DetectSample::v3_0::PzDetectSample</a></div><div class="ttdoc">PzDetectSample defines the structure of a detection sample.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:83</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_a39246df9bccc12078d74da138ecfbfa4"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a39246df9bccc12078d74da138ecfbfa4">PresenZ::DetectSample::v3_0::PzDetectSample::hitPoint</a></div><div class="ttdeci">NozPoint hitPoint</div><div class="ttdoc">Hitpoint in the sample coordinates (see PzSetSampleSpace(Space renderSpace)).</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:100</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_a4c9257ffdd839b215aabfba5f05fa02e"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a4c9257ffdd839b215aabfba5f05fa02e">PresenZ::DetectSample::v3_0::PzDetectSample::hitNormal</a></div><div class="ttdeci">NozPoint hitNormal</div><div class="ttdoc">Normal of the hit point in the sample coordinates (see PzSetSampleSpace(Space renderSpace)).</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:98</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_a5c8e9b74c2fe744a9c5d3a12d81850cf"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a5c8e9b74c2fe744a9c5d3a12d81850cf">PresenZ::DetectSample::v3_0::PzDetectSample::sampleIndex</a></div><div class="ttdeci">size_t sampleIndex</div><div class="ttdoc">The index of the current detect sample.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:94</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_a75f8ddf992db0cfc3cd1aa024086b6f3"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a75f8ddf992db0cfc3cd1aa024086b6f3">PresenZ::DetectSample::v3_0::PzDetectSample::pixelX</a></div><div class="ttdeci">int pixelX</div><div class="ttdoc">Render image x coordinate.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:90</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_a8a33ba6ff4f3da7799e33a2827f9d297"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#a8a33ba6ff4f3da7799e33a2827f9d297">PresenZ::DetectSample::v3_0::PzDetectSample::isChaotic</a></div><div class="ttdeci">bool isChaotic</div><div class="ttdoc">Is the hit object a chaotic geometry.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:88</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_aaa0423628e784003c3f5754ca1e56e70"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#aaa0423628e784003c3f5754ca1e56e70">PresenZ::DetectSample::v3_0::PzDetectSample::pixelY</a></div><div class="ttdeci">int pixelY</div><div class="ttdoc">Render image y coordinate.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:92</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_ad50b77be6452fcd203fa25771dd4f69e"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ad50b77be6452fcd203fa25771dd4f69e">PresenZ::DetectSample::v3_0::PzDetectSample::isHair</a></div><div class="ttdeci">bool isHair</div><div class="ttdoc">Is the hit object tagged as hair.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:86</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample_html_ae89f8742850b3f5fb55f23ccf9a55d86"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_pz_detect_sample.html#ae89f8742850b3f5fb55f23ccf9a55d86">PresenZ::DetectSample::v3_0::PzDetectSample::transpType</a></div><div class="ttdeci">DetectSample_transp transpType</div><div class="ttdoc">Is the hit object opque/glass/semi-Transp.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:96</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface_html"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html">PresenZ::DetectSample::v3_0::RayTestInterface</a></div><div class="ttdoc">This interface is forwarded to PzProcessDetectSample() so that PresenZ can perform an additional visi...</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:63</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface_html_a51c81d3b0c803fbfbeadb4f58c60e2d3"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html#a51c81d3b0c803fbfbeadb4f58c60e2d3">PresenZ::DetectSample::v3_0::RayTestInterface::probe</a></div><div class="ttdeci">RayTestCallback probe</div><div class="ttdoc">Callback for raytracing intersection test.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:67</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface_html_af9b0c64fd8e21243d9d83ed8c1953a53"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html#af9b0c64fd8e21243d9d83ed8c1953a53">PresenZ::DetectSample::v3_0::RayTestInterface::query</a></div><div class="ttdeci">QueryFlagsCallback query</div><div class="ttdoc">Callback for querying render flags.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:69</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface_html_afd0ffb02780e738d4c0a10ab833b7834"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_interface.html#afd0ffb02780e738d4c0a10ab833b7834">PresenZ::DetectSample::v3_0::RayTestInterface::userdata</a></div><div class="ttdeci">void * userdata</div><div class="ttdoc">user data pointer</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:65</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result_html"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html">PresenZ::DetectSample::v3_0::RayTestResult</a></div><div class="ttdoc">RayTestResult is a simplistic structure that holds the 3D hitpoint of the ray, the normal at that poi...</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:45</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result_html_a58649588b953a60c4ab3fb9b2143a87b"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a58649588b953a60c4ab3fb9b2143a87b">PresenZ::DetectSample::v3_0::RayTestResult::normal</a></div><div class="ttdeci">NozVector normal</div><div class="ttdoc">normal at the hitpoint.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:49</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result_html_a873684cefeb665f3d5e6b495de57fc0d"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a873684cefeb665f3d5e6b495de57fc0d">PresenZ::DetectSample::v3_0::RayTestResult::d</a></div><div class="ttdeci">double d</div><div class="ttdoc">distance of ray.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:51</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result_html_a8a33ba6ff4f3da7799e33a2827f9d297"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a8a33ba6ff4f3da7799e33a2827f9d297">PresenZ::DetectSample::v3_0::RayTestResult::isChaotic</a></div><div class="ttdeci">bool isChaotic</div><div class="ttdoc">is the point Chaotic ?</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:53</div></div>
<div class="ttc" id="astruct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result_html_a9d3ba7a09d203fbcadc59723666e37fe"><div class="ttname"><a href="struct_presen_z_1_1_detect_sample_1_1v3__0_1_1_ray_test_result.html#a9d3ba7a09d203fbcadc59723666e37fe">PresenZ::DetectSample::v3_0::RayTestResult::hit</a></div><div class="ttdeci">NozPoint hit</div><div class="ttdoc">3D hitpoint.</div><div class="ttdef"><b>Definition:</b> PzDetectSampleApi.h:47</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex_html"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html">PresenZ::Shading::v3_0::PzBendRayEx</a></div><div class="ttdoc">PzBendRayEx is a structure representing a transparent ray.</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:91</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex_html_a3e1a826396726caf4930542970259fef"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a3e1a826396726caf4930542970259fef">PresenZ::Shading::v3_0::PzBendRayEx::origin</a></div><div class="ttdeci">NozPoint origin</div><div class="ttdoc">ray origin</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:96</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex_html_a9e9c5a557b9f2e0d9331117819cf0df8"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_ex.html#a9e9c5a557b9f2e0d9331117819cf0df8">PresenZ::Shading::v3_0::PzBendRayEx::pzBendRay</a></div><div class="ttdeci">PzBendRay pzBendRay</div><div class="ttdoc">inherited PzBendRay structure</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:92</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_html"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html">PresenZ::Shading::v3_0::PzBendRay</a></div><div class="ttdoc">PzBendRay is a structure representing a bend ray.</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:26</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_html_a25d24f3fc254ac9d7f43b9be22fadd34"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a25d24f3fc254ac9d7f43b9be22fadd34">PresenZ::Shading::v3_0::PzBendRay::isStereoScopic</a></div><div class="ttdeci">bool isStereoScopic</div><div class="ttdoc">can be computed for the other eye.</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:38</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_html_a736153c8076e6040f9703e238e5b987c"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a736153c8076e6040f9703e238e5b987c">PresenZ::Shading::v3_0::PzBendRay::dDdx</a></div><div class="ttdeci">NozVector dDdx</div><div class="ttdoc">world space ray direction derivatives with respect to x</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:32</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_html_a7d4ae5b50b35b0b0e860ffe3192b05da"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#a7d4ae5b50b35b0b0e860ffe3192b05da">PresenZ::Shading::v3_0::PzBendRay::dir</a></div><div class="ttdeci">NozVector dir</div><div class="ttdoc">world space ray direction</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:30</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_html_ab44f0a3b38724b93889067c8dc6e9469"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#ab44f0a3b38724b93889067c8dc6e9469">PresenZ::Shading::v3_0::PzBendRay::wHitDistance</a></div><div class="ttdeci">double wHitDistance</div><div class="ttdoc">world space distance from the specularPoint to the hitPoint</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:36</div></div>
<div class="ttc" id="astruct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray_html_aeb84bfd699fd4a7c535d38f19449e6b4"><div class="ttname"><a href="struct_presen_z_1_1_shading_1_1v3__0_1_1_pz_bend_ray.html#aeb84bfd699fd4a7c535d38f19449e6b4">PresenZ::Shading::v3_0::PzBendRay::dDdy</a></div><div class="ttdeci">NozVector dDdy</div><div class="ttdoc">world space ray direction derivatives with respect to y</div><div class="ttdef"><b>Definition:</b> PzShadingApi.h:34</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md50"></a>
9.3 Render output</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
9.3.1 presenz_render_output.h</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef __PRESENZ_RENDER_OUTPUT_H__</span></div>
<div class="line"><span class="preprocessor">#define __PRESENZ_RENDER_OUTPUT_H__</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PresenZRenderOutput;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This class is mainly used to know when a region is started and finished (regionInit/regionDone). </span></div>
<div class="line"><span class="comment">// Once a region is finished, PresenZ can flush the region data to disk. The region data is freed </span></div>
<div class="line"><span class="comment">// from memory (for now) freeing memory for rendering. All other methods are just calling original </span></div>
<div class="line"><span class="comment">// implementation (origCb).</span></div>
<div class="line"><span class="keyword">class </span>PresenZRegionDoneCallback : <span class="keyword">public</span> VR::RegionDoneCallback</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>PresenZRenderOutput;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    PresenZRegionDoneCallback(PresenZSettings *pSettings) : presenZSettings(pSettings) {}</div>
<div class="line">    <span class="keyword">virtual</span> ~PresenZRegionDoneCallback() {}</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> SetOriginalRegionDoneCallback(VR::RegionDoneCallback* cb) { origCb = cb; }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> renderBegin(VR::VRayRenderer *vray) VRAY_OVERRIDE { <span class="keywordflow">if</span> (origCb) origCb-&gt;renderBegin(vray); }</div>
<div class="line">    <span class="keywordtype">void</span> renderEnd(VR::VRayRenderer *vray) VRAY_OVERRIDE { <span class="keywordflow">if</span> (origCb) origCb-&gt;renderEnd(vray); }</div>
<div class="line">    <span class="keywordtype">void</span> frameEnd(VR::VRayRenderer *vray) VRAY_OVERRIDE { <span class="keywordflow">if</span> (origCb) origCb-&gt;frameEnd(vray); }</div>
<div class="line">    <span class="keywordtype">void</span> imageEnd(VR::VRayRenderer *vray) VRAY_OVERRIDE { <span class="keywordflow">if</span> (origCb) origCb-&gt;imageEnd(vray); }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> frameBegin(VR::VRayRenderer *vray) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> imageBegin(VR::VRayRenderer *vray) VRAY_OVERRIDE;</div>
<div class="line"> </div>
<div class="line">    VR::OutputRegion* newOutput(<span class="keywordtype">int</span> threadIndex) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> deleteOutput(VR::OutputRegion *outrgn, <span class="keywordtype">int</span> threadIndex) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> drawRect(<span class="keyword">const</span> VR::Color &amp;color, <span class="keyword">const</span> VR::Color &amp;transp, <span class="keywordtype">int</span> x0, <span class="keywordtype">int</span> y0, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> updateRect(<span class="keywordtype">int</span> x0, <span class="keywordtype">int</span> y0, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> markRegionRect(<span class="keyword">const</span> RegionRect &amp;rect, <span class="keyword">const</span> <span class="keywordtype">char</span> *str) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> unmarkRegionRect(<span class="keyword">const</span> RegionRect &amp;rect) VRAY_OVERRIDE;</div>
<div class="line"> </div>
<div class="line">    VR::PixelBufferInterface* getImage() VRAY_OVERRIDE;</div>
<div class="line">    PluginInterface* newInterface(InterfaceID <span class="keywordtype">id</span>) VRAY_OVERRIDE;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> regionInit(VR::OutputRegion *rgn, <span class="keywordtype">int</span> threadidx) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> regionDone(VR::OutputRegion *rgn, <span class="keywordtype">int</span> threadidx) VRAY_OVERRIDE;</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line"> </div>
<div class="line">    std::mutex mut_write;</div>
<div class="line">    VR::RegionDoneCallback *origCb;</div>
<div class="line">    PresenZSettings *presenZSettings;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This class is mainly used for distributed rendering. In distributed rendering mode: getBuffer/setBuffer will be </span></div>
<div class="line"><span class="comment">// invoked and PresenZ will serialize the region data onto the buffers that will be sent through the network </span></div>
<div class="line"><span class="comment">// to the target machines. All other methods will result as a call to the original implementation (oldOutputRegion). </span></div>
<div class="line">class PresenZRenderOutput : public VR::OutputRegion </div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    PresenZRenderOutput(VR::OutputRegion *rgn, PresenZRegionDoneCallback *ncb, <span class="keywordtype">int</span> tidx);</div>
<div class="line">    <span class="keyword">virtual</span> ~PresenZRenderOutput() {}</div>
<div class="line">    <span class="keyword">inline</span> VR::OutputRegion* getOrigOutputRegion() { <span class="keywordflow">return</span> oldOutputRegion; }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> getRect(RegionRect &amp;rrect) VRAY_OVERRIDE { oldOutputRegion-&gt;getRect(rrect); }</div>
<div class="line">    <span class="keywordtype">void</span> setRect(<span class="keyword">const</span> RegionRect &amp;rect) VRAY_OVERRIDE { oldOutputRegion-&gt;setRect(rect); }</div>
<div class="line">    <span class="keywordtype">void</span> storeFragmentList(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, VR::FragmentList &amp;fragment) VRAY_OVERRIDE { oldOutputRegion-&gt;storeFragmentList(x, y, fragment); }</div>
<div class="line">    <span class="keywordtype">void</span> clear() VRAY_OVERRIDE { oldOutputRegion-&gt;clear(); }</div>
<div class="line">    <span class="keywordtype">void</span> done() VRAY_OVERRIDE { oldOutputRegion-&gt;done(); }</div>
<div class="line">    <span class="keywordtype">int</span> different(VR::FragmentList &amp;smp0, <span class="keywordtype">int</span> div0, VR::FragmentList &amp;smp1, <span class="keywordtype">int</span> div1, <span class="keywordtype">float</span> edgeLenSq) VRAY_OVERRIDE { <span class="keywordflow">return</span> oldOutputRegion-&gt;different(smp0, div0, smp1, div1, edgeLenSq); }</div>
<div class="line">    VR::Fragment* newFragment() VRAY_OVERRIDE { <span class="keywordflow">return</span> oldOutputRegion-&gt;newFragment(); }</div>
<div class="line">    <span class="keywordtype">void</span> deleteFragment(VR::Fragment *frag) VRAY_OVERRIDE { oldOutputRegion-&gt;deleteFragment(frag); }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getBuffer(<span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> bufSize) VRAY_OVERRIDE;</div>
<div class="line">    <span class="keywordtype">void</span> setBuffer(<span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> bufSize) VRAY_OVERRIDE;</div>
<div class="line">    PluginInterface* newInterface(InterfaceID <span class="keywordtype">id</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> m_hasBeenLocallyInitilialized;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    VR::OutputRegion *oldOutputRegion;</div>
<div class="line">    PresenZRegionDoneCallback *nozonCb;</div>
<div class="line">    <span class="keywordtype">int</span> threadIdx;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">//__PRESENZ_RENDER_OUTPUT_H__</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
9.3.2 presenz_render_output.cpp</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;presenz_settings.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;presenz_render_output.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;renderoutput.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_bucket_api_8h.html">API/PzBucketApi.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_app_logger_8h.html">API/PzAppLogger.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pz_assert_8h.html">API/PzAssert.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>VR;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//************************************************************</span></div>
<div class="line"><span class="comment">// This class wraps the native V-Ray output region, so that we can</span></div>
<div class="line"><span class="comment">// intercept the storeFragmentList() method.</span></div>
<div class="line">PresenZRenderOutput::PresenZRenderOutput(OutputRegion *rgn, PresenZRegionDoneCallback *ncb, <span class="keywordtype">int</span> tidx) :</div>
<div class="line">    oldOutputRegion(rgn),</div>
<div class="line">    nozonCb(ncb),</div>
<div class="line">    threadIdx(tidx),</div>
<div class="line">    m_hasBeenLocallyInitilialized(false)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> PresenZRenderOutput::getBuffer(<span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> bufSize)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> VR::VRaySequenceData *psdata = nozonCb-&gt;presenZSettings-&gt;psdata;</div>
<div class="line"> </div>
<div class="line">    RegionRect rect;</div>
<div class="line">    oldOutputRegion-&gt;getRect(rect);</div>
<div class="line">    <span class="keywordflow">if</span> (buf)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!oldOutputRegion-&gt;getBuffer(buf, bufSize)) {</div>
<div class="line">            <a class="code" href="group___pz_app_logger.html#gafd8b815a0f76d6b121f44f62d5730ee4">PZ_ERROR</a>(<span class="stringliteral">&quot;original vray getBuffer Failed&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (m_hasBeenLocallyInitilialized) </div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">int</span> result = <a class="code" href="group__bucket_a_p_i.html#ga879b16ce8851084bd47d846736692173">PresenZ::BinIO::PzBucketFlushToMemory</a>(buf, bufSize, rect.wx, rect.wy, rect.wx1, rect.wy1);</div>
<div class="line">            <span class="keywordflow">if</span> (!result) {</div>
<div class="line">                <a class="code" href="group___pz_app_logger.html#gafd8b815a0f76d6b121f44f62d5730ee4">PZ_ERROR</a>(<span class="stringliteral">&quot;PresenZ bucket flush to memory Failed&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span> 0;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> bufferSizePresenZ = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (m_hasBeenLocallyInitilialized) {</div>
<div class="line">        bufferSizePresenZ = <a class="code" href="group__bucket_a_p_i.html#ga771f0c9cf79219e3ae681128e92dbcda">PresenZ::BinIO::PzProcessBucketGetBufferSize</a>(rect.wx, rect.wy, rect.wx1, rect.wy1);</div>
<div class="line">        <span class="keywordflow">if</span> (bufferSizePresenZ &lt; 0) {</div>
<div class="line">            <a class="code" href="group___pz_app_logger.html#gafd8b815a0f76d6b121f44f62d5730ee4">PZ_ERROR</a>(<span class="stringliteral">&quot;Failed to get PresenZ region buffer size&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> bufferSizeVray = oldOutputRegion-&gt;getBuffer(<span class="keyword">nullptr</span>, bufSize);</div>
<div class="line">    <span class="keywordflow">if</span> (bufferSizeVray &lt; 0)</div>
<div class="line">        <span class="keywordflow">return</span> bufferSizeVray;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> bufferSizePresenZ + bufferSizeVray;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRenderOutput::setBuffer(<span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> bufSize)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!buf) <span class="keywordflow">return</span>;</div>
<div class="line">    nozonCb-&gt;mut_write.lock();</div>
<div class="line">    RegionRect rect;</div>
<div class="line">    oldOutputRegion-&gt;getRect(rect);</div>
<div class="line">    oldOutputRegion-&gt;setBuffer(buf, bufSize);</div>
<div class="line">    <span class="keywordtype">int</span> th = this-&gt;threadIdx;</div>
<div class="line">    <span class="keyword">const</span> VR::VRaySequenceData *psdata = nozonCb-&gt;presenZSettings-&gt;psdata;</div>
<div class="line">    <span class="keywordflow">if</span> (!m_hasBeenLocallyInitilialized) {</div>
<div class="line">        <a class="code" href="group__bucket_a_p_i.html#gacbe2d059e58e9d8216d026bb2da0e723">PresenZ::BinIO::PzFlushMemoryBufferToFile</a>(buf, bufSize);</div>
<div class="line">    }</div>
<div class="line">    nozonCb-&gt;mut_write.unlock();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">PluginInterface* PresenZRenderOutput::newInterface(InterfaceID <span class="keywordtype">id</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldOutputRegion) <span class="keywordflow">return</span> oldOutputRegion-&gt;newInterface(<span class="keywordtype">id</span>);</div>
<div class="line">    <span class="keywordflow">return</span> OutputRegion::newInterface(<span class="keywordtype">id</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When a region is started, PzInitBucket is invoked, any sample that falls in this </span></div>
<div class="line"><span class="comment">// region will be saved in that specific bucket. </span></div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::regionInit(VR::OutputRegion *rgn, <span class="keywordtype">int</span> threadIdx) {</div>
<div class="line">    PresenZRenderOutput *nozonOut = <span class="keyword">static_cast&lt;</span>PresenZRenderOutput*<span class="keyword">&gt;</span>(rgn);</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;regionInit(nozonOut-&gt;getOrigOutputRegion(), threadIdx);</div>
<div class="line"> </div>
<div class="line">    RegionRect rect;</div>
<div class="line">    rgn-&gt;getRect(rect);</div>
<div class="line"> </div>
<div class="line">    mut_write.lock();</div>
<div class="line">    <a class="code" href="group__bucket_a_p_i.html#ga560ec0137742aa12a1dc91ac6a378461">PresenZ::BinIO::PzInitBucket</a>(threadIdx, rect.wx, rect.wy, rect.wx1, rect.wy1);</div>
<div class="line">    nozonOut-&gt;m_hasBeenLocallyInitilialized = <span class="keyword">true</span>;</div>
<div class="line">    mut_write.unlock();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When a region is finished, we notify PresenZ to write everything to disk </span></div>
<div class="line"><span class="comment">// at once. All internal memory (in PresenZ) related to that region is freed.</span></div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::regionDone(VR::OutputRegion *rgn, <span class="keywordtype">int</span> threadIdx) {</div>
<div class="line">    PresenZRenderOutput *nozonOut = <span class="keyword">static_cast&lt;</span>PresenZRenderOutput*<span class="keyword">&gt;</span>(rgn);</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;regionDone(nozonOut-&gt;getOrigOutputRegion(), threadIdx);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (nozonOut-&gt;m_hasBeenLocallyInitilialized) {</div>
<div class="line">        RegionRect rect;</div>
<div class="line">        rgn-&gt;getRect(rect);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This critical section can be probably removed since we&#39;re directly doing it inside presenz sdk.</span></div>
<div class="line">        <span class="comment">// right before and right after writting the file on the disc.</span></div>
<div class="line">        mut_write.lock(); </div>
<div class="line">        <a class="code" href="group__bucket_a_p_i.html#gadd76ffab50ad3f6597a0b7d7190c80ea">PresenZ::BinIO::PzProcessBucketFlushToFile</a>(rect.wx, rect.wy, rect.wx1, rect.wy1);</div>
<div class="line">        mut_write.unlock();</div>
<div class="line">        </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::frameBegin(VR::VRayRenderer *vray) {</div>
<div class="line"> </div>
<div class="line">    presenZSettings-&gt;lightCacheDone = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;frameBegin(vray);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::imageBegin(VR::VRayRenderer *vray) {</div>
<div class="line"> </div>
<div class="line">    presenZSettings-&gt;lightCacheDone = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keyword">const</span> VRayFrameData &amp;fdata = vray-&gt;getFrameData();</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;imageBegin(vray);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">VR::OutputRegion* PresenZRegionDoneCallback::newOutput(<span class="keywordtype">int</span> threadIndex) {</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) <span class="keywordflow">return</span> <span class="keyword">new</span> PresenZRenderOutput(origCb-&gt;newOutput(threadIndex), <span class="keyword">this</span>, threadIndex);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::deleteOutput(VR::OutputRegion *outrgn, <span class="keywordtype">int</span> threadIndex) {</div>
<div class="line">    PresenZRenderOutput *nozonOut = <span class="keyword">static_cast&lt;</span>PresenZRenderOutput*<span class="keyword">&gt;</span>(outrgn);</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;deleteOutput(nozonOut-&gt;getOrigOutputRegion(), threadIndex);</div>
<div class="line">    <span class="keyword">delete</span> nozonOut;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::drawRect(<span class="keyword">const</span> VR::Color &amp;color, <span class="keyword">const</span> VR::Color &amp;transp, <span class="keywordtype">int</span> x0, <span class="keywordtype">int</span> y0, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1) {</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;drawRect(color, transp, x0, y0, x1, y1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::updateRect(<span class="keywordtype">int</span> x0, <span class="keywordtype">int</span> y0, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1) {</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;updateRect(x0, y0, x1, y1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::markRegionRect(<span class="keyword">const</span> RegionRect &amp;rect, <span class="keyword">const</span> <span class="keywordtype">char</span> *str) {</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;markRegionRect(rect, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PresenZRegionDoneCallback::unmarkRegionRect(<span class="keyword">const</span> RegionRect &amp;rect) {</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) origCb-&gt;unmarkRegionRect(rect);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">VR::PixelBufferInterface* PresenZRegionDoneCallback::getImage() {</div>
<div class="line">    <span class="keywordflow">return</span> origCb? origCb-&gt;getImage() : NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">PluginInterface* PresenZRegionDoneCallback::newInterface(InterfaceID <span class="keywordtype">id</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (origCb) <span class="keywordflow">return</span> origCb-&gt;newInterface(<span class="keywordtype">id</span>);</div>
<div class="line">    <span class="keywordflow">return</span> RegionDoneCallback::newInterface(<span class="keywordtype">id</span>);</div>
<div class="line">}</div>
<div class="ttc" id="a_pz_app_logger_8h_html"><div class="ttname"><a href="_pz_app_logger_8h.html">PzAppLogger.h</a></div></div>
<div class="ttc" id="a_pz_bucket_api_8h_html"><div class="ttname"><a href="_pz_bucket_api_8h.html">PzBucketApi.h</a></div></div>
<div class="ttc" id="agroup___pz_app_logger_html_gafd8b815a0f76d6b121f44f62d5730ee4"><div class="ttname"><a href="group___pz_app_logger.html#gafd8b815a0f76d6b121f44f62d5730ee4">PZ_ERROR</a></div><div class="ttdeci">#define PZ_ERROR(a,...)</div><div class="ttdoc">Printf analog define that forwards an ERROR message to PresenZ logging system.</div><div class="ttdef"><b>Definition:</b> PzAppLogger.h:242</div></div>
<div class="ttc" id="agroup__bucket_a_p_i_html_ga560ec0137742aa12a1dc91ac6a378461"><div class="ttname"><a href="group__bucket_a_p_i.html#ga560ec0137742aa12a1dc91ac6a378461">PresenZ::BinIO::v3_0::PzInitBucket</a></div><div class="ttdeci">void PzInitBucket(const size_t &amp;bucketId, const int &amp;x0, const int &amp;y0, const int &amp;x1, const int &amp;y1)</div><div class="ttdoc">Initialize a bucket (attached to a bucketId) that will contain pixels for the Region [x0,...</div></div>
<div class="ttc" id="agroup__bucket_a_p_i_html_ga771f0c9cf79219e3ae681128e92dbcda"><div class="ttname"><a href="group__bucket_a_p_i.html#ga771f0c9cf79219e3ae681128e92dbcda">PresenZ::BinIO::v3_0::PzProcessBucketGetBufferSize</a></div><div class="ttdeci">int PzProcessBucketGetBufferSize(const size_t &amp;bucketId)</div><div class="ttdoc">Specify how much memory you need to store the processed bucket memory data.</div></div>
<div class="ttc" id="agroup__bucket_a_p_i_html_ga879b16ce8851084bd47d846736692173"><div class="ttname"><a href="group__bucket_a_p_i.html#ga879b16ce8851084bd47d846736692173">PresenZ::BinIO::v3_0::PzBucketFlushToMemory</a></div><div class="ttdeci">bool PzBucketFlushToMemory(void *buffer, const size_t &amp;bufferSize, size_t &amp;bucketId)</div><div class="ttdoc">Write the content of the processed bucket and write the result into a buffer.</div></div>
<div class="ttc" id="agroup__bucket_a_p_i_html_gacbe2d059e58e9d8216d026bb2da0e723"><div class="ttname"><a href="group__bucket_a_p_i.html#gacbe2d059e58e9d8216d026bb2da0e723">PresenZ::BinIO::v3_0::PzFlushMemoryBufferToFile</a></div><div class="ttdeci">bool PzFlushMemoryBufferToFile(const void *buffer, const size_t &amp;bufferSize)</div><div class="ttdoc">De-serialized the data and process the buffer internally.</div></div>
<div class="ttc" id="agroup__bucket_a_p_i_html_gadd76ffab50ad3f6597a0b7d7190c80ea"><div class="ttname"><a href="group__bucket_a_p_i.html#gadd76ffab50ad3f6597a0b7d7190c80ea">PresenZ::BinIO::v3_0::PzProcessBucketFlushToFile</a></div><div class="ttdeci">bool PzProcessBucketFlushToFile(const size_t &amp;bucketId)</div><div class="ttdoc">Process the samples in the bucket into pixels and flush the result to the disk, returns true if succe...</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
